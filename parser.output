Nonterminals useless in grammar

   decl_list
   decl_var
   decl_func
   type_func
   param_list_e
   param_list
   type_param
   type_var
   stmt
   other_stmt
   condition
   if_stmt
   matched_if_stmt
   open_if_stmt
   expr_or_e
   stmt_list_e
   stmt_list


Terminals unused in grammar

   TOKEN_EOF
   ARRAY
   AUTO
   BOOLEAN
   CHAR
   ELSE
   FALSE
   FOR
   FUNCTION
   IF
   INTEGER
   PRINT
   RETURN
   STRING
   TRUE
   VOID
   WHILE
   TOKEN_ERROR
   COMMENT
   SEMICOLON


Rules useless in grammar

   51 decl_list: decl_var decl_list
   52          | decl_func decl_list
   53          | decl_var
   54          | decl_func

   55 decl_var: IDENTIFIER COLON type_var SEMICOLON
   56         | IDENTIFIER COLON type_var EQUALS expr_10 SEMICOLON

   57 decl_func: IDENTIFIER COLON FUNCTION type_func OPEN_PAREN param_list_e CLOSE_PAREN EQUALS OPEN_CURLY stmt_list CLOSE_CURLY
   58          | IDENTIFIER COLON FUNCTION type_func OPEN_PAREN param_list_e CLOSE_PAREN SEMICOLON

   59 type_func: INTEGER
   60          | BOOLEAN
   61          | CHAR
   62          | STRING
   63          | VOID
   64          | AUTO
   65          | FUNCTION type_func

   66 param_list_e: param_list
   67             | %empty

   68 param_list: IDENTIFIER COLON type_param COMMA param_list
   69           | IDENTIFIER COLON type_param

   70 type_param: INTEGER
   71           | BOOLEAN
   72           | CHAR
   73           | STRING
   74           | AUTO
   75           | FUNCTION
   76           | ARRAY OPEN_SQUARE expr_10 CLOSE_SQUARE type_param
   77           | ARRAY OPEN_SQUARE CLOSE_SQUARE type_param

   78 type_var: INTEGER
   79         | BOOLEAN
   80         | CHAR
   81         | STRING
   82         | AUTO
   83         | ARRAY OPEN_SQUARE expr_10 CLOSE_SQUARE type_var
   84         | ARRAY OPEN_SQUARE CLOSE_SQUARE type_var

   85 stmt: if_stmt

   86 other_stmt: RETURN expr_or_e SEMICOLON
   87           | PRINT expr_list_e SEMICOLON
   88           | OPEN_CURLY stmt_list_e CLOSE_CURLY
   89           | expr_10 SEMICOLON
   90           | decl_var

   91 condition: OPEN_PAREN expr_10 CLOSE_PAREN

   92 if_stmt: matched_if_stmt
   93        | open_if_stmt

   94 matched_if_stmt: IF condition matched_if_stmt ELSE matched_if_stmt
   95                | FOR OPEN_PAREN expr_or_e SEMICOLON expr_or_e SEMICOLON expr_or_e CLOSE_PAREN matched_if_stmt
   96                | other_stmt

   97 open_if_stmt: IF condition if_stmt
   98             | IF condition matched_if_stmt ELSE open_if_stmt
   99             | FOR OPEN_PAREN expr_or_e SEMICOLON expr_or_e SEMICOLON expr_or_e CLOSE_PAREN open_if_stmt

  100 expr_or_e: expr_10
  101          | %empty

  102 stmt_list_e: stmt_list
  103            | %empty

  104 stmt_list: stmt stmt_list
  105          | stmt


Grammar

    0 $accept: program $end

    1 program: expr_10
    2        | %empty

    3 expr_10: expr_9 EQUALS expr_10
    4        | expr_9 QUESTION expr_10 COLON expr_10
    5        | expr_9

    6 expr_9: expr_9 OR expr_8
    7       | expr_8

    8 expr_8: expr_8 AND expr_7
    9       | expr_7

   10 expr_7: expr_7 LT expr_6
   11       | expr_7 LE expr_6
   12       | expr_7 EE expr_6
   13       | expr_7 GE expr_6
   14       | expr_7 GT expr_6
   15       | expr_7 NE expr_6
   16       | expr_6

   17 expr_6: expr_6 PLUS expr_5
   18       | expr_6 MINUS expr_5
   19       | expr_5

   20 expr_5: expr_5 MULTIPLY expr_4
   21       | expr_5 DIVIDE expr_4
   22       | expr_5 REMAINDER expr_4
   23       | expr_4

   24 expr_4: expr_3 EXP expr_4
   25       | expr_3

   26 expr_3: MINUS expr_3
   27       | NOT expr_3
   28       | expr_2

   29 expr_2: expr_2 INCREMENT
   30       | expr_2 DECREMENT
   31       | expr_1

   32 expr_1: OPEN_PAREN expr_10 CLOSE_PAREN
   33       | func_call
   34       | array_subscript
   35       | atomic

   36 func_call: ident_name OPEN_PAREN expr_list_e CLOSE_PAREN

   37 ident_name: IDENTIFIER

   38 array_subscript: ident_name bracket_set

   39 bracket_set: OPEN_SQUARE expr_10 CLOSE_SQUARE bracket_set
   40            | OPEN_SQUARE expr_10 CLOSE_SQUARE

   41 expr_list_e: expr_list
   42            | %empty

   43 expr_list: expr_10 COMMA expr_list
   44          | expr_10

   45 atomic: INTEGER_LITERAL
   46       | BOOLEAN_LITERAL
   47       | CHAR_LITERAL
   48       | STRING_LITERAL
   49       | ident_name
   50       | OPEN_CURLY expr_list CLOSE_CURLY


Terminals, with rules where they appear

$end (0) 0
error (256)
TOKEN_EOF (258)
ARRAY (259)
AUTO (260)
BOOLEAN (261)
CHAR (262)
ELSE (263)
FALSE (264)
FOR (265)
FUNCTION (266)
IF (267)
INTEGER (268)
PRINT (269)
RETURN (270)
STRING (271)
TRUE (272)
VOID (273)
WHILE (274)
INTEGER_LITERAL (275) 45
BOOLEAN_LITERAL (276) 46
CHAR_LITERAL (277) 47
STRING_LITERAL (278) 48
IDENTIFIER (279) 37
TOKEN_ERROR (280)
COMMENT (281)
SEMICOLON (282)
COLON (283) 4
QUESTION (284) 4
EQUALS (285) 3
GT (286) 14
GE (287) 13
LT (288) 10
LE (289) 11
EE (290) 12
NE (291) 15
AND (292) 8
OR (293) 6
INCREMENT (294) 29
DECREMENT (295) 30
OPEN_PAREN (296) 32 36
CLOSE_PAREN (297) 32 36
OPEN_SQUARE (298) 39 40
CLOSE_SQUARE (299) 39 40
OPEN_CURLY (300) 50
CLOSE_CURLY (301) 50
PLUS (302) 17
MINUS (303) 18 26
MULTIPLY (304) 20
DIVIDE (305) 21
REMAINDER (306) 22
EXP (307) 24
NOT (308) 27
COMMA (309) 43


Nonterminals, with rules where they appear

$accept (55)
    on left: 0
program (56)
    on left: 1 2, on right: 0
expr_10 (57)
    on left: 3 4 5, on right: 1 3 4 32 39 40 43 44
expr_9 (58)
    on left: 6 7, on right: 3 4 5 6
expr_8 (59)
    on left: 8 9, on right: 6 7 8
expr_7 (60)
    on left: 10 11 12 13 14 15 16, on right: 8 9 10 11 12 13 14 15
expr_6 (61)
    on left: 17 18 19, on right: 10 11 12 13 14 15 16 17 18
expr_5 (62)
    on left: 20 21 22 23, on right: 17 18 19 20 21 22
expr_4 (63)
    on left: 24 25, on right: 20 21 22 23 24
expr_3 (64)
    on left: 26 27 28, on right: 24 25 26 27
expr_2 (65)
    on left: 29 30 31, on right: 28 29 30
expr_1 (66)
    on left: 32 33 34 35, on right: 31
func_call (67)
    on left: 36, on right: 33
ident_name (68)
    on left: 37, on right: 36 38 49
array_subscript (69)
    on left: 38, on right: 34
bracket_set (70)
    on left: 39 40, on right: 38 39
expr_list_e (71)
    on left: 41 42, on right: 36
expr_list (72)
    on left: 43 44, on right: 41 43 50
atomic (73)
    on left: 45 46 47 48 49 50, on right: 35


State 0

    0 $accept: . program $end
    1 program: . expr_10
    2        | . %empty  [$end]
    3 expr_10: . expr_9 EQUALS expr_10
    4        | . expr_9 QUESTION expr_10 COLON expr_10
    5        | . expr_9
    6 expr_9: . expr_9 OR expr_8
    7       | . expr_8
    8 expr_8: . expr_8 AND expr_7
    9       | . expr_7
   10 expr_7: . expr_7 LT expr_6
   11       | . expr_7 LE expr_6
   12       | . expr_7 EE expr_6
   13       | . expr_7 GE expr_6
   14       | . expr_7 GT expr_6
   15       | . expr_7 NE expr_6
   16       | . expr_6
   17 expr_6: . expr_6 PLUS expr_5
   18       | . expr_6 MINUS expr_5
   19       | . expr_5
   20 expr_5: . expr_5 MULTIPLY expr_4
   21       | . expr_5 DIVIDE expr_4
   22       | . expr_5 REMAINDER expr_4
   23       | . expr_4
   24 expr_4: . expr_3 EXP expr_4
   25       | . expr_3
   26 expr_3: . MINUS expr_3
   27       | . NOT expr_3
   28       | . expr_2
   29 expr_2: . expr_2 INCREMENT
   30       | . expr_2 DECREMENT
   31       | . expr_1
   32 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   33       | . func_call
   34       | . array_subscript
   35       | . atomic
   36 func_call: . ident_name OPEN_PAREN expr_list_e CLOSE_PAREN
   37 ident_name: . IDENTIFIER
   38 array_subscript: . ident_name bracket_set
   45 atomic: . INTEGER_LITERAL
   46       | . BOOLEAN_LITERAL
   47       | . CHAR_LITERAL
   48       | . STRING_LITERAL
   49       | . ident_name
   50       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 1
    BOOLEAN_LITERAL  shift, and go to state 2
    CHAR_LITERAL     shift, and go to state 3
    STRING_LITERAL   shift, and go to state 4
    IDENTIFIER       shift, and go to state 5
    OPEN_PAREN       shift, and go to state 6
    OPEN_CURLY       shift, and go to state 7
    MINUS            shift, and go to state 8
    NOT              shift, and go to state 9

    $default  reduce using rule 2 (program)

    program          go to state 10
    expr_10          go to state 11
    expr_9           go to state 12
    expr_8           go to state 13
    expr_7           go to state 14
    expr_6           go to state 15
    expr_5           go to state 16
    expr_4           go to state 17
    expr_3           go to state 18
    expr_2           go to state 19
    expr_1           go to state 20
    func_call        go to state 21
    ident_name       go to state 22
    array_subscript  go to state 23
    atomic           go to state 24


State 1

   45 atomic: INTEGER_LITERAL .

    $default  reduce using rule 45 (atomic)


State 2

   46 atomic: BOOLEAN_LITERAL .

    $default  reduce using rule 46 (atomic)


State 3

   47 atomic: CHAR_LITERAL .

    $default  reduce using rule 47 (atomic)


State 4

   48 atomic: STRING_LITERAL .

    $default  reduce using rule 48 (atomic)


State 5

   37 ident_name: IDENTIFIER .

    $default  reduce using rule 37 (ident_name)


State 6

    3 expr_10: . expr_9 EQUALS expr_10
    4        | . expr_9 QUESTION expr_10 COLON expr_10
    5        | . expr_9
    6 expr_9: . expr_9 OR expr_8
    7       | . expr_8
    8 expr_8: . expr_8 AND expr_7
    9       | . expr_7
   10 expr_7: . expr_7 LT expr_6
   11       | . expr_7 LE expr_6
   12       | . expr_7 EE expr_6
   13       | . expr_7 GE expr_6
   14       | . expr_7 GT expr_6
   15       | . expr_7 NE expr_6
   16       | . expr_6
   17 expr_6: . expr_6 PLUS expr_5
   18       | . expr_6 MINUS expr_5
   19       | . expr_5
   20 expr_5: . expr_5 MULTIPLY expr_4
   21       | . expr_5 DIVIDE expr_4
   22       | . expr_5 REMAINDER expr_4
   23       | . expr_4
   24 expr_4: . expr_3 EXP expr_4
   25       | . expr_3
   26 expr_3: . MINUS expr_3
   27       | . NOT expr_3
   28       | . expr_2
   29 expr_2: . expr_2 INCREMENT
   30       | . expr_2 DECREMENT
   31       | . expr_1
   32 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   32       | OPEN_PAREN . expr_10 CLOSE_PAREN
   33       | . func_call
   34       | . array_subscript
   35       | . atomic
   36 func_call: . ident_name OPEN_PAREN expr_list_e CLOSE_PAREN
   37 ident_name: . IDENTIFIER
   38 array_subscript: . ident_name bracket_set
   45 atomic: . INTEGER_LITERAL
   46       | . BOOLEAN_LITERAL
   47       | . CHAR_LITERAL
   48       | . STRING_LITERAL
   49       | . ident_name
   50       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 1
    BOOLEAN_LITERAL  shift, and go to state 2
    CHAR_LITERAL     shift, and go to state 3
    STRING_LITERAL   shift, and go to state 4
    IDENTIFIER       shift, and go to state 5
    OPEN_PAREN       shift, and go to state 6
    OPEN_CURLY       shift, and go to state 7
    MINUS            shift, and go to state 8
    NOT              shift, and go to state 9

    expr_10          go to state 25
    expr_9           go to state 12
    expr_8           go to state 13
    expr_7           go to state 14
    expr_6           go to state 15
    expr_5           go to state 16
    expr_4           go to state 17
    expr_3           go to state 18
    expr_2           go to state 19
    expr_1           go to state 20
    func_call        go to state 21
    ident_name       go to state 22
    array_subscript  go to state 23
    atomic           go to state 24


State 7

    3 expr_10: . expr_9 EQUALS expr_10
    4        | . expr_9 QUESTION expr_10 COLON expr_10
    5        | . expr_9
    6 expr_9: . expr_9 OR expr_8
    7       | . expr_8
    8 expr_8: . expr_8 AND expr_7
    9       | . expr_7
   10 expr_7: . expr_7 LT expr_6
   11       | . expr_7 LE expr_6
   12       | . expr_7 EE expr_6
   13       | . expr_7 GE expr_6
   14       | . expr_7 GT expr_6
   15       | . expr_7 NE expr_6
   16       | . expr_6
   17 expr_6: . expr_6 PLUS expr_5
   18       | . expr_6 MINUS expr_5
   19       | . expr_5
   20 expr_5: . expr_5 MULTIPLY expr_4
   21       | . expr_5 DIVIDE expr_4
   22       | . expr_5 REMAINDER expr_4
   23       | . expr_4
   24 expr_4: . expr_3 EXP expr_4
   25       | . expr_3
   26 expr_3: . MINUS expr_3
   27       | . NOT expr_3
   28       | . expr_2
   29 expr_2: . expr_2 INCREMENT
   30       | . expr_2 DECREMENT
   31       | . expr_1
   32 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   33       | . func_call
   34       | . array_subscript
   35       | . atomic
   36 func_call: . ident_name OPEN_PAREN expr_list_e CLOSE_PAREN
   37 ident_name: . IDENTIFIER
   38 array_subscript: . ident_name bracket_set
   43 expr_list: . expr_10 COMMA expr_list
   44          | . expr_10
   45 atomic: . INTEGER_LITERAL
   46       | . BOOLEAN_LITERAL
   47       | . CHAR_LITERAL
   48       | . STRING_LITERAL
   49       | . ident_name
   50       | . OPEN_CURLY expr_list CLOSE_CURLY
   50       | OPEN_CURLY . expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 1
    BOOLEAN_LITERAL  shift, and go to state 2
    CHAR_LITERAL     shift, and go to state 3
    STRING_LITERAL   shift, and go to state 4
    IDENTIFIER       shift, and go to state 5
    OPEN_PAREN       shift, and go to state 6
    OPEN_CURLY       shift, and go to state 7
    MINUS            shift, and go to state 8
    NOT              shift, and go to state 9

    expr_10          go to state 26
    expr_9           go to state 12
    expr_8           go to state 13
    expr_7           go to state 14
    expr_6           go to state 15
    expr_5           go to state 16
    expr_4           go to state 17
    expr_3           go to state 18
    expr_2           go to state 19
    expr_1           go to state 20
    func_call        go to state 21
    ident_name       go to state 22
    array_subscript  go to state 23
    expr_list        go to state 27
    atomic           go to state 24


State 8

   26 expr_3: . MINUS expr_3
   26       | MINUS . expr_3
   27       | . NOT expr_3
   28       | . expr_2
   29 expr_2: . expr_2 INCREMENT
   30       | . expr_2 DECREMENT
   31       | . expr_1
   32 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   33       | . func_call
   34       | . array_subscript
   35       | . atomic
   36 func_call: . ident_name OPEN_PAREN expr_list_e CLOSE_PAREN
   37 ident_name: . IDENTIFIER
   38 array_subscript: . ident_name bracket_set
   45 atomic: . INTEGER_LITERAL
   46       | . BOOLEAN_LITERAL
   47       | . CHAR_LITERAL
   48       | . STRING_LITERAL
   49       | . ident_name
   50       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 1
    BOOLEAN_LITERAL  shift, and go to state 2
    CHAR_LITERAL     shift, and go to state 3
    STRING_LITERAL   shift, and go to state 4
    IDENTIFIER       shift, and go to state 5
    OPEN_PAREN       shift, and go to state 6
    OPEN_CURLY       shift, and go to state 7
    MINUS            shift, and go to state 8
    NOT              shift, and go to state 9

    expr_3           go to state 28
    expr_2           go to state 19
    expr_1           go to state 20
    func_call        go to state 21
    ident_name       go to state 22
    array_subscript  go to state 23
    atomic           go to state 24


State 9

   26 expr_3: . MINUS expr_3
   27       | . NOT expr_3
   27       | NOT . expr_3
   28       | . expr_2
   29 expr_2: . expr_2 INCREMENT
   30       | . expr_2 DECREMENT
   31       | . expr_1
   32 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   33       | . func_call
   34       | . array_subscript
   35       | . atomic
   36 func_call: . ident_name OPEN_PAREN expr_list_e CLOSE_PAREN
   37 ident_name: . IDENTIFIER
   38 array_subscript: . ident_name bracket_set
   45 atomic: . INTEGER_LITERAL
   46       | . BOOLEAN_LITERAL
   47       | . CHAR_LITERAL
   48       | . STRING_LITERAL
   49       | . ident_name
   50       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 1
    BOOLEAN_LITERAL  shift, and go to state 2
    CHAR_LITERAL     shift, and go to state 3
    STRING_LITERAL   shift, and go to state 4
    IDENTIFIER       shift, and go to state 5
    OPEN_PAREN       shift, and go to state 6
    OPEN_CURLY       shift, and go to state 7
    MINUS            shift, and go to state 8
    NOT              shift, and go to state 9

    expr_3           go to state 29
    expr_2           go to state 19
    expr_1           go to state 20
    func_call        go to state 21
    ident_name       go to state 22
    array_subscript  go to state 23
    atomic           go to state 24


State 10

    0 $accept: program . $end

    $end  shift, and go to state 30


State 11

    1 program: expr_10 .

    $default  reduce using rule 1 (program)


State 12

    3 expr_10: expr_9 . EQUALS expr_10
    4        | expr_9 . QUESTION expr_10 COLON expr_10
    5        | expr_9 .  [$end, COLON, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, COMMA]
    6 expr_9: expr_9 . OR expr_8

    QUESTION  shift, and go to state 31
    EQUALS    shift, and go to state 32
    OR        shift, and go to state 33

    $default  reduce using rule 5 (expr_10)


State 13

    7 expr_9: expr_8 .  [$end, COLON, QUESTION, EQUALS, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, COMMA]
    8 expr_8: expr_8 . AND expr_7

    AND  shift, and go to state 34

    $default  reduce using rule 7 (expr_9)


State 14

    9 expr_8: expr_7 .  [$end, COLON, QUESTION, EQUALS, AND, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, COMMA]
   10 expr_7: expr_7 . LT expr_6
   11       | expr_7 . LE expr_6
   12       | expr_7 . EE expr_6
   13       | expr_7 . GE expr_6
   14       | expr_7 . GT expr_6
   15       | expr_7 . NE expr_6

    GT  shift, and go to state 35
    GE  shift, and go to state 36
    LT  shift, and go to state 37
    LE  shift, and go to state 38
    EE  shift, and go to state 39
    NE  shift, and go to state 40

    $default  reduce using rule 9 (expr_8)


State 15

   16 expr_7: expr_6 .  [$end, COLON, QUESTION, EQUALS, GT, GE, LT, LE, EE, NE, AND, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, COMMA]
   17 expr_6: expr_6 . PLUS expr_5
   18       | expr_6 . MINUS expr_5

    PLUS   shift, and go to state 41
    MINUS  shift, and go to state 42

    $default  reduce using rule 16 (expr_7)


State 16

   19 expr_6: expr_5 .  [$end, COLON, QUESTION, EQUALS, GT, GE, LT, LE, EE, NE, AND, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, PLUS, MINUS, COMMA]
   20 expr_5: expr_5 . MULTIPLY expr_4
   21       | expr_5 . DIVIDE expr_4
   22       | expr_5 . REMAINDER expr_4

    MULTIPLY   shift, and go to state 43
    DIVIDE     shift, and go to state 44
    REMAINDER  shift, and go to state 45

    $default  reduce using rule 19 (expr_6)


State 17

   23 expr_5: expr_4 .

    $default  reduce using rule 23 (expr_5)


State 18

   24 expr_4: expr_3 . EXP expr_4
   25       | expr_3 .  [$end, COLON, QUESTION, EQUALS, GT, GE, LT, LE, EE, NE, AND, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, PLUS, MINUS, MULTIPLY, DIVIDE, REMAINDER, COMMA]

    EXP  shift, and go to state 46

    $default  reduce using rule 25 (expr_4)


State 19

   28 expr_3: expr_2 .  [$end, COLON, QUESTION, EQUALS, GT, GE, LT, LE, EE, NE, AND, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, PLUS, MINUS, MULTIPLY, DIVIDE, REMAINDER, EXP, COMMA]
   29 expr_2: expr_2 . INCREMENT
   30       | expr_2 . DECREMENT

    INCREMENT  shift, and go to state 47
    DECREMENT  shift, and go to state 48

    $default  reduce using rule 28 (expr_3)


State 20

   31 expr_2: expr_1 .

    $default  reduce using rule 31 (expr_2)


State 21

   33 expr_1: func_call .

    $default  reduce using rule 33 (expr_1)


State 22

   36 func_call: ident_name . OPEN_PAREN expr_list_e CLOSE_PAREN
   38 array_subscript: ident_name . bracket_set
   39 bracket_set: . OPEN_SQUARE expr_10 CLOSE_SQUARE bracket_set
   40            | . OPEN_SQUARE expr_10 CLOSE_SQUARE
   49 atomic: ident_name .  [$end, COLON, QUESTION, EQUALS, GT, GE, LT, LE, EE, NE, AND, OR, INCREMENT, DECREMENT, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, PLUS, MINUS, MULTIPLY, DIVIDE, REMAINDER, EXP, COMMA]

    OPEN_PAREN   shift, and go to state 49
    OPEN_SQUARE  shift, and go to state 50

    $default  reduce using rule 49 (atomic)

    bracket_set  go to state 51


State 23

   34 expr_1: array_subscript .

    $default  reduce using rule 34 (expr_1)


State 24

   35 expr_1: atomic .

    $default  reduce using rule 35 (expr_1)


State 25

   32 expr_1: OPEN_PAREN expr_10 . CLOSE_PAREN

    CLOSE_PAREN  shift, and go to state 52


State 26

   43 expr_list: expr_10 . COMMA expr_list
   44          | expr_10 .  [CLOSE_PAREN, CLOSE_CURLY]

    COMMA  shift, and go to state 53

    $default  reduce using rule 44 (expr_list)


State 27

   50 atomic: OPEN_CURLY expr_list . CLOSE_CURLY

    CLOSE_CURLY  shift, and go to state 54


State 28

   26 expr_3: MINUS expr_3 .

    $default  reduce using rule 26 (expr_3)


State 29

   27 expr_3: NOT expr_3 .

    $default  reduce using rule 27 (expr_3)


State 30

    0 $accept: program $end .

    $default  accept


State 31

    3 expr_10: . expr_9 EQUALS expr_10
    4        | . expr_9 QUESTION expr_10 COLON expr_10
    4        | expr_9 QUESTION . expr_10 COLON expr_10
    5        | . expr_9
    6 expr_9: . expr_9 OR expr_8
    7       | . expr_8
    8 expr_8: . expr_8 AND expr_7
    9       | . expr_7
   10 expr_7: . expr_7 LT expr_6
   11       | . expr_7 LE expr_6
   12       | . expr_7 EE expr_6
   13       | . expr_7 GE expr_6
   14       | . expr_7 GT expr_6
   15       | . expr_7 NE expr_6
   16       | . expr_6
   17 expr_6: . expr_6 PLUS expr_5
   18       | . expr_6 MINUS expr_5
   19       | . expr_5
   20 expr_5: . expr_5 MULTIPLY expr_4
   21       | . expr_5 DIVIDE expr_4
   22       | . expr_5 REMAINDER expr_4
   23       | . expr_4
   24 expr_4: . expr_3 EXP expr_4
   25       | . expr_3
   26 expr_3: . MINUS expr_3
   27       | . NOT expr_3
   28       | . expr_2
   29 expr_2: . expr_2 INCREMENT
   30       | . expr_2 DECREMENT
   31       | . expr_1
   32 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   33       | . func_call
   34       | . array_subscript
   35       | . atomic
   36 func_call: . ident_name OPEN_PAREN expr_list_e CLOSE_PAREN
   37 ident_name: . IDENTIFIER
   38 array_subscript: . ident_name bracket_set
   45 atomic: . INTEGER_LITERAL
   46       | . BOOLEAN_LITERAL
   47       | . CHAR_LITERAL
   48       | . STRING_LITERAL
   49       | . ident_name
   50       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 1
    BOOLEAN_LITERAL  shift, and go to state 2
    CHAR_LITERAL     shift, and go to state 3
    STRING_LITERAL   shift, and go to state 4
    IDENTIFIER       shift, and go to state 5
    OPEN_PAREN       shift, and go to state 6
    OPEN_CURLY       shift, and go to state 7
    MINUS            shift, and go to state 8
    NOT              shift, and go to state 9

    expr_10          go to state 55
    expr_9           go to state 12
    expr_8           go to state 13
    expr_7           go to state 14
    expr_6           go to state 15
    expr_5           go to state 16
    expr_4           go to state 17
    expr_3           go to state 18
    expr_2           go to state 19
    expr_1           go to state 20
    func_call        go to state 21
    ident_name       go to state 22
    array_subscript  go to state 23
    atomic           go to state 24


State 32

    3 expr_10: . expr_9 EQUALS expr_10
    3        | expr_9 EQUALS . expr_10
    4        | . expr_9 QUESTION expr_10 COLON expr_10
    5        | . expr_9
    6 expr_9: . expr_9 OR expr_8
    7       | . expr_8
    8 expr_8: . expr_8 AND expr_7
    9       | . expr_7
   10 expr_7: . expr_7 LT expr_6
   11       | . expr_7 LE expr_6
   12       | . expr_7 EE expr_6
   13       | . expr_7 GE expr_6
   14       | . expr_7 GT expr_6
   15       | . expr_7 NE expr_6
   16       | . expr_6
   17 expr_6: . expr_6 PLUS expr_5
   18       | . expr_6 MINUS expr_5
   19       | . expr_5
   20 expr_5: . expr_5 MULTIPLY expr_4
   21       | . expr_5 DIVIDE expr_4
   22       | . expr_5 REMAINDER expr_4
   23       | . expr_4
   24 expr_4: . expr_3 EXP expr_4
   25       | . expr_3
   26 expr_3: . MINUS expr_3
   27       | . NOT expr_3
   28       | . expr_2
   29 expr_2: . expr_2 INCREMENT
   30       | . expr_2 DECREMENT
   31       | . expr_1
   32 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   33       | . func_call
   34       | . array_subscript
   35       | . atomic
   36 func_call: . ident_name OPEN_PAREN expr_list_e CLOSE_PAREN
   37 ident_name: . IDENTIFIER
   38 array_subscript: . ident_name bracket_set
   45 atomic: . INTEGER_LITERAL
   46       | . BOOLEAN_LITERAL
   47       | . CHAR_LITERAL
   48       | . STRING_LITERAL
   49       | . ident_name
   50       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 1
    BOOLEAN_LITERAL  shift, and go to state 2
    CHAR_LITERAL     shift, and go to state 3
    STRING_LITERAL   shift, and go to state 4
    IDENTIFIER       shift, and go to state 5
    OPEN_PAREN       shift, and go to state 6
    OPEN_CURLY       shift, and go to state 7
    MINUS            shift, and go to state 8
    NOT              shift, and go to state 9

    expr_10          go to state 56
    expr_9           go to state 12
    expr_8           go to state 13
    expr_7           go to state 14
    expr_6           go to state 15
    expr_5           go to state 16
    expr_4           go to state 17
    expr_3           go to state 18
    expr_2           go to state 19
    expr_1           go to state 20
    func_call        go to state 21
    ident_name       go to state 22
    array_subscript  go to state 23
    atomic           go to state 24


State 33

    6 expr_9: expr_9 OR . expr_8
    8 expr_8: . expr_8 AND expr_7
    9       | . expr_7
   10 expr_7: . expr_7 LT expr_6
   11       | . expr_7 LE expr_6
   12       | . expr_7 EE expr_6
   13       | . expr_7 GE expr_6
   14       | . expr_7 GT expr_6
   15       | . expr_7 NE expr_6
   16       | . expr_6
   17 expr_6: . expr_6 PLUS expr_5
   18       | . expr_6 MINUS expr_5
   19       | . expr_5
   20 expr_5: . expr_5 MULTIPLY expr_4
   21       | . expr_5 DIVIDE expr_4
   22       | . expr_5 REMAINDER expr_4
   23       | . expr_4
   24 expr_4: . expr_3 EXP expr_4
   25       | . expr_3
   26 expr_3: . MINUS expr_3
   27       | . NOT expr_3
   28       | . expr_2
   29 expr_2: . expr_2 INCREMENT
   30       | . expr_2 DECREMENT
   31       | . expr_1
   32 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   33       | . func_call
   34       | . array_subscript
   35       | . atomic
   36 func_call: . ident_name OPEN_PAREN expr_list_e CLOSE_PAREN
   37 ident_name: . IDENTIFIER
   38 array_subscript: . ident_name bracket_set
   45 atomic: . INTEGER_LITERAL
   46       | . BOOLEAN_LITERAL
   47       | . CHAR_LITERAL
   48       | . STRING_LITERAL
   49       | . ident_name
   50       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 1
    BOOLEAN_LITERAL  shift, and go to state 2
    CHAR_LITERAL     shift, and go to state 3
    STRING_LITERAL   shift, and go to state 4
    IDENTIFIER       shift, and go to state 5
    OPEN_PAREN       shift, and go to state 6
    OPEN_CURLY       shift, and go to state 7
    MINUS            shift, and go to state 8
    NOT              shift, and go to state 9

    expr_8           go to state 57
    expr_7           go to state 14
    expr_6           go to state 15
    expr_5           go to state 16
    expr_4           go to state 17
    expr_3           go to state 18
    expr_2           go to state 19
    expr_1           go to state 20
    func_call        go to state 21
    ident_name       go to state 22
    array_subscript  go to state 23
    atomic           go to state 24


State 34

    8 expr_8: expr_8 AND . expr_7
   10 expr_7: . expr_7 LT expr_6
   11       | . expr_7 LE expr_6
   12       | . expr_7 EE expr_6
   13       | . expr_7 GE expr_6
   14       | . expr_7 GT expr_6
   15       | . expr_7 NE expr_6
   16       | . expr_6
   17 expr_6: . expr_6 PLUS expr_5
   18       | . expr_6 MINUS expr_5
   19       | . expr_5
   20 expr_5: . expr_5 MULTIPLY expr_4
   21       | . expr_5 DIVIDE expr_4
   22       | . expr_5 REMAINDER expr_4
   23       | . expr_4
   24 expr_4: . expr_3 EXP expr_4
   25       | . expr_3
   26 expr_3: . MINUS expr_3
   27       | . NOT expr_3
   28       | . expr_2
   29 expr_2: . expr_2 INCREMENT
   30       | . expr_2 DECREMENT
   31       | . expr_1
   32 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   33       | . func_call
   34       | . array_subscript
   35       | . atomic
   36 func_call: . ident_name OPEN_PAREN expr_list_e CLOSE_PAREN
   37 ident_name: . IDENTIFIER
   38 array_subscript: . ident_name bracket_set
   45 atomic: . INTEGER_LITERAL
   46       | . BOOLEAN_LITERAL
   47       | . CHAR_LITERAL
   48       | . STRING_LITERAL
   49       | . ident_name
   50       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 1
    BOOLEAN_LITERAL  shift, and go to state 2
    CHAR_LITERAL     shift, and go to state 3
    STRING_LITERAL   shift, and go to state 4
    IDENTIFIER       shift, and go to state 5
    OPEN_PAREN       shift, and go to state 6
    OPEN_CURLY       shift, and go to state 7
    MINUS            shift, and go to state 8
    NOT              shift, and go to state 9

    expr_7           go to state 58
    expr_6           go to state 15
    expr_5           go to state 16
    expr_4           go to state 17
    expr_3           go to state 18
    expr_2           go to state 19
    expr_1           go to state 20
    func_call        go to state 21
    ident_name       go to state 22
    array_subscript  go to state 23
    atomic           go to state 24


State 35

   14 expr_7: expr_7 GT . expr_6
   17 expr_6: . expr_6 PLUS expr_5
   18       | . expr_6 MINUS expr_5
   19       | . expr_5
   20 expr_5: . expr_5 MULTIPLY expr_4
   21       | . expr_5 DIVIDE expr_4
   22       | . expr_5 REMAINDER expr_4
   23       | . expr_4
   24 expr_4: . expr_3 EXP expr_4
   25       | . expr_3
   26 expr_3: . MINUS expr_3
   27       | . NOT expr_3
   28       | . expr_2
   29 expr_2: . expr_2 INCREMENT
   30       | . expr_2 DECREMENT
   31       | . expr_1
   32 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   33       | . func_call
   34       | . array_subscript
   35       | . atomic
   36 func_call: . ident_name OPEN_PAREN expr_list_e CLOSE_PAREN
   37 ident_name: . IDENTIFIER
   38 array_subscript: . ident_name bracket_set
   45 atomic: . INTEGER_LITERAL
   46       | . BOOLEAN_LITERAL
   47       | . CHAR_LITERAL
   48       | . STRING_LITERAL
   49       | . ident_name
   50       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 1
    BOOLEAN_LITERAL  shift, and go to state 2
    CHAR_LITERAL     shift, and go to state 3
    STRING_LITERAL   shift, and go to state 4
    IDENTIFIER       shift, and go to state 5
    OPEN_PAREN       shift, and go to state 6
    OPEN_CURLY       shift, and go to state 7
    MINUS            shift, and go to state 8
    NOT              shift, and go to state 9

    expr_6           go to state 59
    expr_5           go to state 16
    expr_4           go to state 17
    expr_3           go to state 18
    expr_2           go to state 19
    expr_1           go to state 20
    func_call        go to state 21
    ident_name       go to state 22
    array_subscript  go to state 23
    atomic           go to state 24


State 36

   13 expr_7: expr_7 GE . expr_6
   17 expr_6: . expr_6 PLUS expr_5
   18       | . expr_6 MINUS expr_5
   19       | . expr_5
   20 expr_5: . expr_5 MULTIPLY expr_4
   21       | . expr_5 DIVIDE expr_4
   22       | . expr_5 REMAINDER expr_4
   23       | . expr_4
   24 expr_4: . expr_3 EXP expr_4
   25       | . expr_3
   26 expr_3: . MINUS expr_3
   27       | . NOT expr_3
   28       | . expr_2
   29 expr_2: . expr_2 INCREMENT
   30       | . expr_2 DECREMENT
   31       | . expr_1
   32 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   33       | . func_call
   34       | . array_subscript
   35       | . atomic
   36 func_call: . ident_name OPEN_PAREN expr_list_e CLOSE_PAREN
   37 ident_name: . IDENTIFIER
   38 array_subscript: . ident_name bracket_set
   45 atomic: . INTEGER_LITERAL
   46       | . BOOLEAN_LITERAL
   47       | . CHAR_LITERAL
   48       | . STRING_LITERAL
   49       | . ident_name
   50       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 1
    BOOLEAN_LITERAL  shift, and go to state 2
    CHAR_LITERAL     shift, and go to state 3
    STRING_LITERAL   shift, and go to state 4
    IDENTIFIER       shift, and go to state 5
    OPEN_PAREN       shift, and go to state 6
    OPEN_CURLY       shift, and go to state 7
    MINUS            shift, and go to state 8
    NOT              shift, and go to state 9

    expr_6           go to state 60
    expr_5           go to state 16
    expr_4           go to state 17
    expr_3           go to state 18
    expr_2           go to state 19
    expr_1           go to state 20
    func_call        go to state 21
    ident_name       go to state 22
    array_subscript  go to state 23
    atomic           go to state 24


State 37

   10 expr_7: expr_7 LT . expr_6
   17 expr_6: . expr_6 PLUS expr_5
   18       | . expr_6 MINUS expr_5
   19       | . expr_5
   20 expr_5: . expr_5 MULTIPLY expr_4
   21       | . expr_5 DIVIDE expr_4
   22       | . expr_5 REMAINDER expr_4
   23       | . expr_4
   24 expr_4: . expr_3 EXP expr_4
   25       | . expr_3
   26 expr_3: . MINUS expr_3
   27       | . NOT expr_3
   28       | . expr_2
   29 expr_2: . expr_2 INCREMENT
   30       | . expr_2 DECREMENT
   31       | . expr_1
   32 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   33       | . func_call
   34       | . array_subscript
   35       | . atomic
   36 func_call: . ident_name OPEN_PAREN expr_list_e CLOSE_PAREN
   37 ident_name: . IDENTIFIER
   38 array_subscript: . ident_name bracket_set
   45 atomic: . INTEGER_LITERAL
   46       | . BOOLEAN_LITERAL
   47       | . CHAR_LITERAL
   48       | . STRING_LITERAL
   49       | . ident_name
   50       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 1
    BOOLEAN_LITERAL  shift, and go to state 2
    CHAR_LITERAL     shift, and go to state 3
    STRING_LITERAL   shift, and go to state 4
    IDENTIFIER       shift, and go to state 5
    OPEN_PAREN       shift, and go to state 6
    OPEN_CURLY       shift, and go to state 7
    MINUS            shift, and go to state 8
    NOT              shift, and go to state 9

    expr_6           go to state 61
    expr_5           go to state 16
    expr_4           go to state 17
    expr_3           go to state 18
    expr_2           go to state 19
    expr_1           go to state 20
    func_call        go to state 21
    ident_name       go to state 22
    array_subscript  go to state 23
    atomic           go to state 24


State 38

   11 expr_7: expr_7 LE . expr_6
   17 expr_6: . expr_6 PLUS expr_5
   18       | . expr_6 MINUS expr_5
   19       | . expr_5
   20 expr_5: . expr_5 MULTIPLY expr_4
   21       | . expr_5 DIVIDE expr_4
   22       | . expr_5 REMAINDER expr_4
   23       | . expr_4
   24 expr_4: . expr_3 EXP expr_4
   25       | . expr_3
   26 expr_3: . MINUS expr_3
   27       | . NOT expr_3
   28       | . expr_2
   29 expr_2: . expr_2 INCREMENT
   30       | . expr_2 DECREMENT
   31       | . expr_1
   32 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   33       | . func_call
   34       | . array_subscript
   35       | . atomic
   36 func_call: . ident_name OPEN_PAREN expr_list_e CLOSE_PAREN
   37 ident_name: . IDENTIFIER
   38 array_subscript: . ident_name bracket_set
   45 atomic: . INTEGER_LITERAL
   46       | . BOOLEAN_LITERAL
   47       | . CHAR_LITERAL
   48       | . STRING_LITERAL
   49       | . ident_name
   50       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 1
    BOOLEAN_LITERAL  shift, and go to state 2
    CHAR_LITERAL     shift, and go to state 3
    STRING_LITERAL   shift, and go to state 4
    IDENTIFIER       shift, and go to state 5
    OPEN_PAREN       shift, and go to state 6
    OPEN_CURLY       shift, and go to state 7
    MINUS            shift, and go to state 8
    NOT              shift, and go to state 9

    expr_6           go to state 62
    expr_5           go to state 16
    expr_4           go to state 17
    expr_3           go to state 18
    expr_2           go to state 19
    expr_1           go to state 20
    func_call        go to state 21
    ident_name       go to state 22
    array_subscript  go to state 23
    atomic           go to state 24


State 39

   12 expr_7: expr_7 EE . expr_6
   17 expr_6: . expr_6 PLUS expr_5
   18       | . expr_6 MINUS expr_5
   19       | . expr_5
   20 expr_5: . expr_5 MULTIPLY expr_4
   21       | . expr_5 DIVIDE expr_4
   22       | . expr_5 REMAINDER expr_4
   23       | . expr_4
   24 expr_4: . expr_3 EXP expr_4
   25       | . expr_3
   26 expr_3: . MINUS expr_3
   27       | . NOT expr_3
   28       | . expr_2
   29 expr_2: . expr_2 INCREMENT
   30       | . expr_2 DECREMENT
   31       | . expr_1
   32 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   33       | . func_call
   34       | . array_subscript
   35       | . atomic
   36 func_call: . ident_name OPEN_PAREN expr_list_e CLOSE_PAREN
   37 ident_name: . IDENTIFIER
   38 array_subscript: . ident_name bracket_set
   45 atomic: . INTEGER_LITERAL
   46       | . BOOLEAN_LITERAL
   47       | . CHAR_LITERAL
   48       | . STRING_LITERAL
   49       | . ident_name
   50       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 1
    BOOLEAN_LITERAL  shift, and go to state 2
    CHAR_LITERAL     shift, and go to state 3
    STRING_LITERAL   shift, and go to state 4
    IDENTIFIER       shift, and go to state 5
    OPEN_PAREN       shift, and go to state 6
    OPEN_CURLY       shift, and go to state 7
    MINUS            shift, and go to state 8
    NOT              shift, and go to state 9

    expr_6           go to state 63
    expr_5           go to state 16
    expr_4           go to state 17
    expr_3           go to state 18
    expr_2           go to state 19
    expr_1           go to state 20
    func_call        go to state 21
    ident_name       go to state 22
    array_subscript  go to state 23
    atomic           go to state 24


State 40

   15 expr_7: expr_7 NE . expr_6
   17 expr_6: . expr_6 PLUS expr_5
   18       | . expr_6 MINUS expr_5
   19       | . expr_5
   20 expr_5: . expr_5 MULTIPLY expr_4
   21       | . expr_5 DIVIDE expr_4
   22       | . expr_5 REMAINDER expr_4
   23       | . expr_4
   24 expr_4: . expr_3 EXP expr_4
   25       | . expr_3
   26 expr_3: . MINUS expr_3
   27       | . NOT expr_3
   28       | . expr_2
   29 expr_2: . expr_2 INCREMENT
   30       | . expr_2 DECREMENT
   31       | . expr_1
   32 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   33       | . func_call
   34       | . array_subscript
   35       | . atomic
   36 func_call: . ident_name OPEN_PAREN expr_list_e CLOSE_PAREN
   37 ident_name: . IDENTIFIER
   38 array_subscript: . ident_name bracket_set
   45 atomic: . INTEGER_LITERAL
   46       | . BOOLEAN_LITERAL
   47       | . CHAR_LITERAL
   48       | . STRING_LITERAL
   49       | . ident_name
   50       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 1
    BOOLEAN_LITERAL  shift, and go to state 2
    CHAR_LITERAL     shift, and go to state 3
    STRING_LITERAL   shift, and go to state 4
    IDENTIFIER       shift, and go to state 5
    OPEN_PAREN       shift, and go to state 6
    OPEN_CURLY       shift, and go to state 7
    MINUS            shift, and go to state 8
    NOT              shift, and go to state 9

    expr_6           go to state 64
    expr_5           go to state 16
    expr_4           go to state 17
    expr_3           go to state 18
    expr_2           go to state 19
    expr_1           go to state 20
    func_call        go to state 21
    ident_name       go to state 22
    array_subscript  go to state 23
    atomic           go to state 24


State 41

   17 expr_6: expr_6 PLUS . expr_5
   20 expr_5: . expr_5 MULTIPLY expr_4
   21       | . expr_5 DIVIDE expr_4
   22       | . expr_5 REMAINDER expr_4
   23       | . expr_4
   24 expr_4: . expr_3 EXP expr_4
   25       | . expr_3
   26 expr_3: . MINUS expr_3
   27       | . NOT expr_3
   28       | . expr_2
   29 expr_2: . expr_2 INCREMENT
   30       | . expr_2 DECREMENT
   31       | . expr_1
   32 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   33       | . func_call
   34       | . array_subscript
   35       | . atomic
   36 func_call: . ident_name OPEN_PAREN expr_list_e CLOSE_PAREN
   37 ident_name: . IDENTIFIER
   38 array_subscript: . ident_name bracket_set
   45 atomic: . INTEGER_LITERAL
   46       | . BOOLEAN_LITERAL
   47       | . CHAR_LITERAL
   48       | . STRING_LITERAL
   49       | . ident_name
   50       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 1
    BOOLEAN_LITERAL  shift, and go to state 2
    CHAR_LITERAL     shift, and go to state 3
    STRING_LITERAL   shift, and go to state 4
    IDENTIFIER       shift, and go to state 5
    OPEN_PAREN       shift, and go to state 6
    OPEN_CURLY       shift, and go to state 7
    MINUS            shift, and go to state 8
    NOT              shift, and go to state 9

    expr_5           go to state 65
    expr_4           go to state 17
    expr_3           go to state 18
    expr_2           go to state 19
    expr_1           go to state 20
    func_call        go to state 21
    ident_name       go to state 22
    array_subscript  go to state 23
    atomic           go to state 24


State 42

   18 expr_6: expr_6 MINUS . expr_5
   20 expr_5: . expr_5 MULTIPLY expr_4
   21       | . expr_5 DIVIDE expr_4
   22       | . expr_5 REMAINDER expr_4
   23       | . expr_4
   24 expr_4: . expr_3 EXP expr_4
   25       | . expr_3
   26 expr_3: . MINUS expr_3
   27       | . NOT expr_3
   28       | . expr_2
   29 expr_2: . expr_2 INCREMENT
   30       | . expr_2 DECREMENT
   31       | . expr_1
   32 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   33       | . func_call
   34       | . array_subscript
   35       | . atomic
   36 func_call: . ident_name OPEN_PAREN expr_list_e CLOSE_PAREN
   37 ident_name: . IDENTIFIER
   38 array_subscript: . ident_name bracket_set
   45 atomic: . INTEGER_LITERAL
   46       | . BOOLEAN_LITERAL
   47       | . CHAR_LITERAL
   48       | . STRING_LITERAL
   49       | . ident_name
   50       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 1
    BOOLEAN_LITERAL  shift, and go to state 2
    CHAR_LITERAL     shift, and go to state 3
    STRING_LITERAL   shift, and go to state 4
    IDENTIFIER       shift, and go to state 5
    OPEN_PAREN       shift, and go to state 6
    OPEN_CURLY       shift, and go to state 7
    MINUS            shift, and go to state 8
    NOT              shift, and go to state 9

    expr_5           go to state 66
    expr_4           go to state 17
    expr_3           go to state 18
    expr_2           go to state 19
    expr_1           go to state 20
    func_call        go to state 21
    ident_name       go to state 22
    array_subscript  go to state 23
    atomic           go to state 24


State 43

   20 expr_5: expr_5 MULTIPLY . expr_4
   24 expr_4: . expr_3 EXP expr_4
   25       | . expr_3
   26 expr_3: . MINUS expr_3
   27       | . NOT expr_3
   28       | . expr_2
   29 expr_2: . expr_2 INCREMENT
   30       | . expr_2 DECREMENT
   31       | . expr_1
   32 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   33       | . func_call
   34       | . array_subscript
   35       | . atomic
   36 func_call: . ident_name OPEN_PAREN expr_list_e CLOSE_PAREN
   37 ident_name: . IDENTIFIER
   38 array_subscript: . ident_name bracket_set
   45 atomic: . INTEGER_LITERAL
   46       | . BOOLEAN_LITERAL
   47       | . CHAR_LITERAL
   48       | . STRING_LITERAL
   49       | . ident_name
   50       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 1
    BOOLEAN_LITERAL  shift, and go to state 2
    CHAR_LITERAL     shift, and go to state 3
    STRING_LITERAL   shift, and go to state 4
    IDENTIFIER       shift, and go to state 5
    OPEN_PAREN       shift, and go to state 6
    OPEN_CURLY       shift, and go to state 7
    MINUS            shift, and go to state 8
    NOT              shift, and go to state 9

    expr_4           go to state 67
    expr_3           go to state 18
    expr_2           go to state 19
    expr_1           go to state 20
    func_call        go to state 21
    ident_name       go to state 22
    array_subscript  go to state 23
    atomic           go to state 24


State 44

   21 expr_5: expr_5 DIVIDE . expr_4
   24 expr_4: . expr_3 EXP expr_4
   25       | . expr_3
   26 expr_3: . MINUS expr_3
   27       | . NOT expr_3
   28       | . expr_2
   29 expr_2: . expr_2 INCREMENT
   30       | . expr_2 DECREMENT
   31       | . expr_1
   32 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   33       | . func_call
   34       | . array_subscript
   35       | . atomic
   36 func_call: . ident_name OPEN_PAREN expr_list_e CLOSE_PAREN
   37 ident_name: . IDENTIFIER
   38 array_subscript: . ident_name bracket_set
   45 atomic: . INTEGER_LITERAL
   46       | . BOOLEAN_LITERAL
   47       | . CHAR_LITERAL
   48       | . STRING_LITERAL
   49       | . ident_name
   50       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 1
    BOOLEAN_LITERAL  shift, and go to state 2
    CHAR_LITERAL     shift, and go to state 3
    STRING_LITERAL   shift, and go to state 4
    IDENTIFIER       shift, and go to state 5
    OPEN_PAREN       shift, and go to state 6
    OPEN_CURLY       shift, and go to state 7
    MINUS            shift, and go to state 8
    NOT              shift, and go to state 9

    expr_4           go to state 68
    expr_3           go to state 18
    expr_2           go to state 19
    expr_1           go to state 20
    func_call        go to state 21
    ident_name       go to state 22
    array_subscript  go to state 23
    atomic           go to state 24


State 45

   22 expr_5: expr_5 REMAINDER . expr_4
   24 expr_4: . expr_3 EXP expr_4
   25       | . expr_3
   26 expr_3: . MINUS expr_3
   27       | . NOT expr_3
   28       | . expr_2
   29 expr_2: . expr_2 INCREMENT
   30       | . expr_2 DECREMENT
   31       | . expr_1
   32 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   33       | . func_call
   34       | . array_subscript
   35       | . atomic
   36 func_call: . ident_name OPEN_PAREN expr_list_e CLOSE_PAREN
   37 ident_name: . IDENTIFIER
   38 array_subscript: . ident_name bracket_set
   45 atomic: . INTEGER_LITERAL
   46       | . BOOLEAN_LITERAL
   47       | . CHAR_LITERAL
   48       | . STRING_LITERAL
   49       | . ident_name
   50       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 1
    BOOLEAN_LITERAL  shift, and go to state 2
    CHAR_LITERAL     shift, and go to state 3
    STRING_LITERAL   shift, and go to state 4
    IDENTIFIER       shift, and go to state 5
    OPEN_PAREN       shift, and go to state 6
    OPEN_CURLY       shift, and go to state 7
    MINUS            shift, and go to state 8
    NOT              shift, and go to state 9

    expr_4           go to state 69
    expr_3           go to state 18
    expr_2           go to state 19
    expr_1           go to state 20
    func_call        go to state 21
    ident_name       go to state 22
    array_subscript  go to state 23
    atomic           go to state 24


State 46

   24 expr_4: . expr_3 EXP expr_4
   24       | expr_3 EXP . expr_4
   25       | . expr_3
   26 expr_3: . MINUS expr_3
   27       | . NOT expr_3
   28       | . expr_2
   29 expr_2: . expr_2 INCREMENT
   30       | . expr_2 DECREMENT
   31       | . expr_1
   32 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   33       | . func_call
   34       | . array_subscript
   35       | . atomic
   36 func_call: . ident_name OPEN_PAREN expr_list_e CLOSE_PAREN
   37 ident_name: . IDENTIFIER
   38 array_subscript: . ident_name bracket_set
   45 atomic: . INTEGER_LITERAL
   46       | . BOOLEAN_LITERAL
   47       | . CHAR_LITERAL
   48       | . STRING_LITERAL
   49       | . ident_name
   50       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 1
    BOOLEAN_LITERAL  shift, and go to state 2
    CHAR_LITERAL     shift, and go to state 3
    STRING_LITERAL   shift, and go to state 4
    IDENTIFIER       shift, and go to state 5
    OPEN_PAREN       shift, and go to state 6
    OPEN_CURLY       shift, and go to state 7
    MINUS            shift, and go to state 8
    NOT              shift, and go to state 9

    expr_4           go to state 70
    expr_3           go to state 18
    expr_2           go to state 19
    expr_1           go to state 20
    func_call        go to state 21
    ident_name       go to state 22
    array_subscript  go to state 23
    atomic           go to state 24


State 47

   29 expr_2: expr_2 INCREMENT .

    $default  reduce using rule 29 (expr_2)


State 48

   30 expr_2: expr_2 DECREMENT .

    $default  reduce using rule 30 (expr_2)


State 49

    3 expr_10: . expr_9 EQUALS expr_10
    4        | . expr_9 QUESTION expr_10 COLON expr_10
    5        | . expr_9
    6 expr_9: . expr_9 OR expr_8
    7       | . expr_8
    8 expr_8: . expr_8 AND expr_7
    9       | . expr_7
   10 expr_7: . expr_7 LT expr_6
   11       | . expr_7 LE expr_6
   12       | . expr_7 EE expr_6
   13       | . expr_7 GE expr_6
   14       | . expr_7 GT expr_6
   15       | . expr_7 NE expr_6
   16       | . expr_6
   17 expr_6: . expr_6 PLUS expr_5
   18       | . expr_6 MINUS expr_5
   19       | . expr_5
   20 expr_5: . expr_5 MULTIPLY expr_4
   21       | . expr_5 DIVIDE expr_4
   22       | . expr_5 REMAINDER expr_4
   23       | . expr_4
   24 expr_4: . expr_3 EXP expr_4
   25       | . expr_3
   26 expr_3: . MINUS expr_3
   27       | . NOT expr_3
   28       | . expr_2
   29 expr_2: . expr_2 INCREMENT
   30       | . expr_2 DECREMENT
   31       | . expr_1
   32 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   33       | . func_call
   34       | . array_subscript
   35       | . atomic
   36 func_call: . ident_name OPEN_PAREN expr_list_e CLOSE_PAREN
   36          | ident_name OPEN_PAREN . expr_list_e CLOSE_PAREN
   37 ident_name: . IDENTIFIER
   38 array_subscript: . ident_name bracket_set
   41 expr_list_e: . expr_list
   42            | . %empty  [CLOSE_PAREN]
   43 expr_list: . expr_10 COMMA expr_list
   44          | . expr_10
   45 atomic: . INTEGER_LITERAL
   46       | . BOOLEAN_LITERAL
   47       | . CHAR_LITERAL
   48       | . STRING_LITERAL
   49       | . ident_name
   50       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 1
    BOOLEAN_LITERAL  shift, and go to state 2
    CHAR_LITERAL     shift, and go to state 3
    STRING_LITERAL   shift, and go to state 4
    IDENTIFIER       shift, and go to state 5
    OPEN_PAREN       shift, and go to state 6
    OPEN_CURLY       shift, and go to state 7
    MINUS            shift, and go to state 8
    NOT              shift, and go to state 9

    $default  reduce using rule 42 (expr_list_e)

    expr_10          go to state 26
    expr_9           go to state 12
    expr_8           go to state 13
    expr_7           go to state 14
    expr_6           go to state 15
    expr_5           go to state 16
    expr_4           go to state 17
    expr_3           go to state 18
    expr_2           go to state 19
    expr_1           go to state 20
    func_call        go to state 21
    ident_name       go to state 22
    array_subscript  go to state 23
    expr_list_e      go to state 71
    expr_list        go to state 72
    atomic           go to state 24


State 50

    3 expr_10: . expr_9 EQUALS expr_10
    4        | . expr_9 QUESTION expr_10 COLON expr_10
    5        | . expr_9
    6 expr_9: . expr_9 OR expr_8
    7       | . expr_8
    8 expr_8: . expr_8 AND expr_7
    9       | . expr_7
   10 expr_7: . expr_7 LT expr_6
   11       | . expr_7 LE expr_6
   12       | . expr_7 EE expr_6
   13       | . expr_7 GE expr_6
   14       | . expr_7 GT expr_6
   15       | . expr_7 NE expr_6
   16       | . expr_6
   17 expr_6: . expr_6 PLUS expr_5
   18       | . expr_6 MINUS expr_5
   19       | . expr_5
   20 expr_5: . expr_5 MULTIPLY expr_4
   21       | . expr_5 DIVIDE expr_4
   22       | . expr_5 REMAINDER expr_4
   23       | . expr_4
   24 expr_4: . expr_3 EXP expr_4
   25       | . expr_3
   26 expr_3: . MINUS expr_3
   27       | . NOT expr_3
   28       | . expr_2
   29 expr_2: . expr_2 INCREMENT
   30       | . expr_2 DECREMENT
   31       | . expr_1
   32 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   33       | . func_call
   34       | . array_subscript
   35       | . atomic
   36 func_call: . ident_name OPEN_PAREN expr_list_e CLOSE_PAREN
   37 ident_name: . IDENTIFIER
   38 array_subscript: . ident_name bracket_set
   39 bracket_set: OPEN_SQUARE . expr_10 CLOSE_SQUARE bracket_set
   40            | OPEN_SQUARE . expr_10 CLOSE_SQUARE
   45 atomic: . INTEGER_LITERAL
   46       | . BOOLEAN_LITERAL
   47       | . CHAR_LITERAL
   48       | . STRING_LITERAL
   49       | . ident_name
   50       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 1
    BOOLEAN_LITERAL  shift, and go to state 2
    CHAR_LITERAL     shift, and go to state 3
    STRING_LITERAL   shift, and go to state 4
    IDENTIFIER       shift, and go to state 5
    OPEN_PAREN       shift, and go to state 6
    OPEN_CURLY       shift, and go to state 7
    MINUS            shift, and go to state 8
    NOT              shift, and go to state 9

    expr_10          go to state 73
    expr_9           go to state 12
    expr_8           go to state 13
    expr_7           go to state 14
    expr_6           go to state 15
    expr_5           go to state 16
    expr_4           go to state 17
    expr_3           go to state 18
    expr_2           go to state 19
    expr_1           go to state 20
    func_call        go to state 21
    ident_name       go to state 22
    array_subscript  go to state 23
    atomic           go to state 24


State 51

   38 array_subscript: ident_name bracket_set .

    $default  reduce using rule 38 (array_subscript)


State 52

   32 expr_1: OPEN_PAREN expr_10 CLOSE_PAREN .

    $default  reduce using rule 32 (expr_1)


State 53

    3 expr_10: . expr_9 EQUALS expr_10
    4        | . expr_9 QUESTION expr_10 COLON expr_10
    5        | . expr_9
    6 expr_9: . expr_9 OR expr_8
    7       | . expr_8
    8 expr_8: . expr_8 AND expr_7
    9       | . expr_7
   10 expr_7: . expr_7 LT expr_6
   11       | . expr_7 LE expr_6
   12       | . expr_7 EE expr_6
   13       | . expr_7 GE expr_6
   14       | . expr_7 GT expr_6
   15       | . expr_7 NE expr_6
   16       | . expr_6
   17 expr_6: . expr_6 PLUS expr_5
   18       | . expr_6 MINUS expr_5
   19       | . expr_5
   20 expr_5: . expr_5 MULTIPLY expr_4
   21       | . expr_5 DIVIDE expr_4
   22       | . expr_5 REMAINDER expr_4
   23       | . expr_4
   24 expr_4: . expr_3 EXP expr_4
   25       | . expr_3
   26 expr_3: . MINUS expr_3
   27       | . NOT expr_3
   28       | . expr_2
   29 expr_2: . expr_2 INCREMENT
   30       | . expr_2 DECREMENT
   31       | . expr_1
   32 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   33       | . func_call
   34       | . array_subscript
   35       | . atomic
   36 func_call: . ident_name OPEN_PAREN expr_list_e CLOSE_PAREN
   37 ident_name: . IDENTIFIER
   38 array_subscript: . ident_name bracket_set
   43 expr_list: . expr_10 COMMA expr_list
   43          | expr_10 COMMA . expr_list
   44          | . expr_10
   45 atomic: . INTEGER_LITERAL
   46       | . BOOLEAN_LITERAL
   47       | . CHAR_LITERAL
   48       | . STRING_LITERAL
   49       | . ident_name
   50       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 1
    BOOLEAN_LITERAL  shift, and go to state 2
    CHAR_LITERAL     shift, and go to state 3
    STRING_LITERAL   shift, and go to state 4
    IDENTIFIER       shift, and go to state 5
    OPEN_PAREN       shift, and go to state 6
    OPEN_CURLY       shift, and go to state 7
    MINUS            shift, and go to state 8
    NOT              shift, and go to state 9

    expr_10          go to state 26
    expr_9           go to state 12
    expr_8           go to state 13
    expr_7           go to state 14
    expr_6           go to state 15
    expr_5           go to state 16
    expr_4           go to state 17
    expr_3           go to state 18
    expr_2           go to state 19
    expr_1           go to state 20
    func_call        go to state 21
    ident_name       go to state 22
    array_subscript  go to state 23
    expr_list        go to state 74
    atomic           go to state 24


State 54

   50 atomic: OPEN_CURLY expr_list CLOSE_CURLY .

    $default  reduce using rule 50 (atomic)


State 55

    4 expr_10: expr_9 QUESTION expr_10 . COLON expr_10

    COLON  shift, and go to state 75


State 56

    3 expr_10: expr_9 EQUALS expr_10 .

    $default  reduce using rule 3 (expr_10)


State 57

    6 expr_9: expr_9 OR expr_8 .  [$end, COLON, QUESTION, EQUALS, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, COMMA]
    8 expr_8: expr_8 . AND expr_7

    AND  shift, and go to state 34

    $default  reduce using rule 6 (expr_9)


State 58

    8 expr_8: expr_8 AND expr_7 .  [$end, COLON, QUESTION, EQUALS, AND, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, COMMA]
   10 expr_7: expr_7 . LT expr_6
   11       | expr_7 . LE expr_6
   12       | expr_7 . EE expr_6
   13       | expr_7 . GE expr_6
   14       | expr_7 . GT expr_6
   15       | expr_7 . NE expr_6

    GT  shift, and go to state 35
    GE  shift, and go to state 36
    LT  shift, and go to state 37
    LE  shift, and go to state 38
    EE  shift, and go to state 39
    NE  shift, and go to state 40

    $default  reduce using rule 8 (expr_8)


State 59

   14 expr_7: expr_7 GT expr_6 .  [$end, COLON, QUESTION, EQUALS, GT, GE, LT, LE, EE, NE, AND, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, COMMA]
   17 expr_6: expr_6 . PLUS expr_5
   18       | expr_6 . MINUS expr_5

    PLUS   shift, and go to state 41
    MINUS  shift, and go to state 42

    $default  reduce using rule 14 (expr_7)


State 60

   13 expr_7: expr_7 GE expr_6 .  [$end, COLON, QUESTION, EQUALS, GT, GE, LT, LE, EE, NE, AND, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, COMMA]
   17 expr_6: expr_6 . PLUS expr_5
   18       | expr_6 . MINUS expr_5

    PLUS   shift, and go to state 41
    MINUS  shift, and go to state 42

    $default  reduce using rule 13 (expr_7)


State 61

   10 expr_7: expr_7 LT expr_6 .  [$end, COLON, QUESTION, EQUALS, GT, GE, LT, LE, EE, NE, AND, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, COMMA]
   17 expr_6: expr_6 . PLUS expr_5
   18       | expr_6 . MINUS expr_5

    PLUS   shift, and go to state 41
    MINUS  shift, and go to state 42

    $default  reduce using rule 10 (expr_7)


State 62

   11 expr_7: expr_7 LE expr_6 .  [$end, COLON, QUESTION, EQUALS, GT, GE, LT, LE, EE, NE, AND, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, COMMA]
   17 expr_6: expr_6 . PLUS expr_5
   18       | expr_6 . MINUS expr_5

    PLUS   shift, and go to state 41
    MINUS  shift, and go to state 42

    $default  reduce using rule 11 (expr_7)


State 63

   12 expr_7: expr_7 EE expr_6 .  [$end, COLON, QUESTION, EQUALS, GT, GE, LT, LE, EE, NE, AND, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, COMMA]
   17 expr_6: expr_6 . PLUS expr_5
   18       | expr_6 . MINUS expr_5

    PLUS   shift, and go to state 41
    MINUS  shift, and go to state 42

    $default  reduce using rule 12 (expr_7)


State 64

   15 expr_7: expr_7 NE expr_6 .  [$end, COLON, QUESTION, EQUALS, GT, GE, LT, LE, EE, NE, AND, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, COMMA]
   17 expr_6: expr_6 . PLUS expr_5
   18       | expr_6 . MINUS expr_5

    PLUS   shift, and go to state 41
    MINUS  shift, and go to state 42

    $default  reduce using rule 15 (expr_7)


State 65

   17 expr_6: expr_6 PLUS expr_5 .  [$end, COLON, QUESTION, EQUALS, GT, GE, LT, LE, EE, NE, AND, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, PLUS, MINUS, COMMA]
   20 expr_5: expr_5 . MULTIPLY expr_4
   21       | expr_5 . DIVIDE expr_4
   22       | expr_5 . REMAINDER expr_4

    MULTIPLY   shift, and go to state 43
    DIVIDE     shift, and go to state 44
    REMAINDER  shift, and go to state 45

    $default  reduce using rule 17 (expr_6)


State 66

   18 expr_6: expr_6 MINUS expr_5 .  [$end, COLON, QUESTION, EQUALS, GT, GE, LT, LE, EE, NE, AND, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, PLUS, MINUS, COMMA]
   20 expr_5: expr_5 . MULTIPLY expr_4
   21       | expr_5 . DIVIDE expr_4
   22       | expr_5 . REMAINDER expr_4

    MULTIPLY   shift, and go to state 43
    DIVIDE     shift, and go to state 44
    REMAINDER  shift, and go to state 45

    $default  reduce using rule 18 (expr_6)


State 67

   20 expr_5: expr_5 MULTIPLY expr_4 .

    $default  reduce using rule 20 (expr_5)


State 68

   21 expr_5: expr_5 DIVIDE expr_4 .

    $default  reduce using rule 21 (expr_5)


State 69

   22 expr_5: expr_5 REMAINDER expr_4 .

    $default  reduce using rule 22 (expr_5)


State 70

   24 expr_4: expr_3 EXP expr_4 .

    $default  reduce using rule 24 (expr_4)


State 71

   36 func_call: ident_name OPEN_PAREN expr_list_e . CLOSE_PAREN

    CLOSE_PAREN  shift, and go to state 76


State 72

   41 expr_list_e: expr_list .

    $default  reduce using rule 41 (expr_list_e)


State 73

   39 bracket_set: OPEN_SQUARE expr_10 . CLOSE_SQUARE bracket_set
   40            | OPEN_SQUARE expr_10 . CLOSE_SQUARE

    CLOSE_SQUARE  shift, and go to state 77


State 74

   43 expr_list: expr_10 COMMA expr_list .

    $default  reduce using rule 43 (expr_list)


State 75

    3 expr_10: . expr_9 EQUALS expr_10
    4        | . expr_9 QUESTION expr_10 COLON expr_10
    4        | expr_9 QUESTION expr_10 COLON . expr_10
    5        | . expr_9
    6 expr_9: . expr_9 OR expr_8
    7       | . expr_8
    8 expr_8: . expr_8 AND expr_7
    9       | . expr_7
   10 expr_7: . expr_7 LT expr_6
   11       | . expr_7 LE expr_6
   12       | . expr_7 EE expr_6
   13       | . expr_7 GE expr_6
   14       | . expr_7 GT expr_6
   15       | . expr_7 NE expr_6
   16       | . expr_6
   17 expr_6: . expr_6 PLUS expr_5
   18       | . expr_6 MINUS expr_5
   19       | . expr_5
   20 expr_5: . expr_5 MULTIPLY expr_4
   21       | . expr_5 DIVIDE expr_4
   22       | . expr_5 REMAINDER expr_4
   23       | . expr_4
   24 expr_4: . expr_3 EXP expr_4
   25       | . expr_3
   26 expr_3: . MINUS expr_3
   27       | . NOT expr_3
   28       | . expr_2
   29 expr_2: . expr_2 INCREMENT
   30       | . expr_2 DECREMENT
   31       | . expr_1
   32 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   33       | . func_call
   34       | . array_subscript
   35       | . atomic
   36 func_call: . ident_name OPEN_PAREN expr_list_e CLOSE_PAREN
   37 ident_name: . IDENTIFIER
   38 array_subscript: . ident_name bracket_set
   45 atomic: . INTEGER_LITERAL
   46       | . BOOLEAN_LITERAL
   47       | . CHAR_LITERAL
   48       | . STRING_LITERAL
   49       | . ident_name
   50       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 1
    BOOLEAN_LITERAL  shift, and go to state 2
    CHAR_LITERAL     shift, and go to state 3
    STRING_LITERAL   shift, and go to state 4
    IDENTIFIER       shift, and go to state 5
    OPEN_PAREN       shift, and go to state 6
    OPEN_CURLY       shift, and go to state 7
    MINUS            shift, and go to state 8
    NOT              shift, and go to state 9

    expr_10          go to state 78
    expr_9           go to state 12
    expr_8           go to state 13
    expr_7           go to state 14
    expr_6           go to state 15
    expr_5           go to state 16
    expr_4           go to state 17
    expr_3           go to state 18
    expr_2           go to state 19
    expr_1           go to state 20
    func_call        go to state 21
    ident_name       go to state 22
    array_subscript  go to state 23
    atomic           go to state 24


State 76

   36 func_call: ident_name OPEN_PAREN expr_list_e CLOSE_PAREN .

    $default  reduce using rule 36 (func_call)


State 77

   39 bracket_set: . OPEN_SQUARE expr_10 CLOSE_SQUARE bracket_set
   39            | OPEN_SQUARE expr_10 CLOSE_SQUARE . bracket_set
   40            | . OPEN_SQUARE expr_10 CLOSE_SQUARE
   40            | OPEN_SQUARE expr_10 CLOSE_SQUARE .  [$end, COLON, QUESTION, EQUALS, GT, GE, LT, LE, EE, NE, AND, OR, INCREMENT, DECREMENT, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, PLUS, MINUS, MULTIPLY, DIVIDE, REMAINDER, EXP, COMMA]

    OPEN_SQUARE  shift, and go to state 50

    $default  reduce using rule 40 (bracket_set)

    bracket_set  go to state 79


State 78

    4 expr_10: expr_9 QUESTION expr_10 COLON expr_10 .

    $default  reduce using rule 4 (expr_10)


State 79

   39 bracket_set: OPEN_SQUARE expr_10 CLOSE_SQUARE bracket_set .

    $default  reduce using rule 39 (bracket_set)
