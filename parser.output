Terminals unused in grammar

   TOKEN_EOF
   FALSE
   TRUE
   WHILE
   TOKEN_ERROR
   COMMENT


State 166 conflicts: 1 shift/reduce


Grammar

    0 $accept: program $end

    1 program: decl_list
    2        | %empty

    3 decl_list: decl_var decl_list
    4          | decl_func decl_list
    5          | decl_var
    6          | decl_func

    7 decl_var: IDENTIFIER COLON type_var SEMICOLON
    8         | IDENTIFIER COLON type_var EQUALS expr_10 SEMICOLON

    9 decl_func: IDENTIFIER COLON FUNCTION type_func OPEN_PAREN param_list_e CLOSE_PAREN EQUALS OPEN_CURLY stmt_list CLOSE_CURLY
   10          | IDENTIFIER COLON FUNCTION type_func OPEN_PAREN param_list_e CLOSE_PAREN SEMICOLON

   11 type_func: INTEGER
   12          | BOOLEAN
   13          | CHAR
   14          | STRING
   15          | VOID

   16 param_list_e: param_list
   17             | %empty

   18 param_list: IDENTIFIER COLON type_param COMMA param_list
   19           | IDENTIFIER COLON type_param

   20 type_param: INTEGER
   21           | BOOLEAN
   22           | CHAR
   23           | STRING
   24           | AUTO
   25           | ARRAY OPEN_SQUARE expr_10 CLOSE_SQUARE type_param
   26           | ARRAY OPEN_SQUARE CLOSE_SQUARE type_param

   27 type_var: INTEGER
   28         | BOOLEAN
   29         | CHAR
   30         | STRING
   31         | AUTO
   32         | ARRAY OPEN_SQUARE expr_10 CLOSE_SQUARE type_var

   33 stmt: if_stmt

   34 other_stmt: RETURN expr_10 SEMICOLON
   35           | RETURN SEMICOLON
   36           | PRINT expr_list_e SEMICOLON
   37           | OPEN_CURLY stmt_list CLOSE_CURLY
   38           | expr_10 SEMICOLON
   39           | FOR OPEN_PAREN expr_or_e SEMICOLON expr_or_e SEMICOLON expr_or_e CLOSE_PAREN stmt
   40           | decl_var

   41 if_stmt: matched_if_stmt
   42        | open_if_stmt

   43 matched_if_stmt: IF OPEN_PAREN expr_10 CLOSE_PAREN matched_if_stmt ELSE matched_if_stmt
   44                | other_stmt

   45 open_if_stmt: IF OPEN_PAREN expr_10 CLOSE_PAREN if_stmt
   46             | IF OPEN_PAREN expr_10 CLOSE_PAREN matched_if_stmt ELSE open_if_stmt

   47 expr_or_e: expr_10
   48          | %empty

   49 stmt_list: stmt stmt_list
   50          | stmt

   51 expr_10: expr_9 EQUALS expr_10
   52        | expr_9 QUESTION expr_10 COLON expr_10
   53        | expr_9

   54 expr_9: expr_9 OR expr_8
   55       | expr_8

   56 expr_8: expr_8 AND expr_7
   57       | expr_7

   58 expr_7: expr_7 LT expr_6
   59       | expr_7 LE expr_6
   60       | expr_7 EE expr_6
   61       | expr_7 GE expr_6
   62       | expr_7 GT expr_6
   63       | expr_7 NE expr_6
   64       | expr_6

   65 expr_6: expr_6 PLUS expr_5
   66       | expr_6 MINUS expr_5
   67       | expr_5

   68 expr_5: expr_5 MULTIPLY expr_4
   69       | expr_5 DIVIDE expr_4
   70       | expr_5 REMAINDER expr_4
   71       | expr_4

   72 expr_4: expr_3 EXP expr_4
   73       | expr_3

   74 expr_3: MINUS expr_3
   75       | NOT expr_3
   76       | expr_2

   77 expr_2: expr_2 INCREMENT
   78       | expr_2 DECREMENT
   79       | expr_1

   80 expr_1: OPEN_PAREN expr_10 CLOSE_PAREN
   81       | func_call
   82       | array_subscript
   83       | atomic

   84 func_call: IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN

   85 array_subscript: IDENTIFIER bracket_set

   86 bracket_set: OPEN_SQUARE expr_10 CLOSE_SQUARE bracket_set
   87            | OPEN_SQUARE expr_10 CLOSE_SQUARE

   88 expr_list_e: expr_list
   89            | %empty

   90 expr_list: expr_10 COMMA expr_list
   91          | expr_10

   92 atomic: INTEGER_LITERAL
   93       | BOOLEAN_LITERAL
   94       | CHAR_LITERAL
   95       | STRING_LITERAL
   96       | IDENTIFIER
   97       | OPEN_CURLY expr_list CLOSE_CURLY


Terminals, with rules where they appear

$end (0) 0
error (256)
TOKEN_EOF (258)
ARRAY (259) 25 26 32
AUTO (260) 24 31
BOOLEAN (261) 12 21 28
CHAR (262) 13 22 29
ELSE (263) 43 46
FALSE (264)
FOR (265) 39
FUNCTION (266) 9 10
IF (267) 43 45 46
INTEGER (268) 11 20 27
PRINT (269) 36
RETURN (270) 34 35
STRING (271) 14 23 30
TRUE (272)
VOID (273) 15
WHILE (274)
INTEGER_LITERAL (275) 92
BOOLEAN_LITERAL (276) 93
CHAR_LITERAL (277) 94
STRING_LITERAL (278) 95
IDENTIFIER (279) 7 8 9 10 18 19 84 85 96
TOKEN_ERROR (280)
COMMENT (281)
SEMICOLON (282) 7 8 10 34 35 36 38 39
COLON (283) 7 8 9 10 18 19 52
QUESTION (284) 52
EQUALS (285) 8 9 51
GT (286) 62
GE (287) 61
LT (288) 58
LE (289) 59
EE (290) 60
NE (291) 63
AND (292) 56
OR (293) 54
INCREMENT (294) 77
DECREMENT (295) 78
OPEN_PAREN (296) 9 10 39 43 45 46 80 84
CLOSE_PAREN (297) 9 10 39 43 45 46 80 84
OPEN_SQUARE (298) 25 26 32 86 87
CLOSE_SQUARE (299) 25 26 32 86 87
OPEN_CURLY (300) 9 37 97
CLOSE_CURLY (301) 9 37 97
PLUS (302) 65
MINUS (303) 66 74
MULTIPLY (304) 68
DIVIDE (305) 69
REMAINDER (306) 70
EXP (307) 72
NOT (308) 75
COMMA (309) 18 90


Nonterminals, with rules where they appear

$accept (55)
    on left: 0
program (56)
    on left: 1 2, on right: 0
decl_list (57)
    on left: 3 4 5 6, on right: 1 3 4
decl_var (58)
    on left: 7 8, on right: 3 5 40
decl_func (59)
    on left: 9 10, on right: 4 6
type_func (60)
    on left: 11 12 13 14 15, on right: 9 10
param_list_e (61)
    on left: 16 17, on right: 9 10
param_list (62)
    on left: 18 19, on right: 16 18
type_param (63)
    on left: 20 21 22 23 24 25 26, on right: 18 19 25 26
type_var (64)
    on left: 27 28 29 30 31 32, on right: 7 8 32
stmt (65)
    on left: 33, on right: 39 49 50
other_stmt (66)
    on left: 34 35 36 37 38 39 40, on right: 44
if_stmt (67)
    on left: 41 42, on right: 33 45
matched_if_stmt (68)
    on left: 43 44, on right: 41 43 46
open_if_stmt (69)
    on left: 45 46, on right: 42 46
expr_or_e (70)
    on left: 47 48, on right: 39
stmt_list (71)
    on left: 49 50, on right: 9 37 49
expr_10 (72)
    on left: 51 52 53, on right: 8 25 32 34 38 43 45 46 47 51 52 80
    86 87 90 91
expr_9 (73)
    on left: 54 55, on right: 51 52 53 54
expr_8 (74)
    on left: 56 57, on right: 54 55 56
expr_7 (75)
    on left: 58 59 60 61 62 63 64, on right: 56 57 58 59 60 61 62 63
expr_6 (76)
    on left: 65 66 67, on right: 58 59 60 61 62 63 64 65 66
expr_5 (77)
    on left: 68 69 70 71, on right: 65 66 67 68 69 70
expr_4 (78)
    on left: 72 73, on right: 68 69 70 71 72
expr_3 (79)
    on left: 74 75 76, on right: 72 73 74 75
expr_2 (80)
    on left: 77 78 79, on right: 76 77 78
expr_1 (81)
    on left: 80 81 82 83, on right: 79
func_call (82)
    on left: 84, on right: 81
array_subscript (83)
    on left: 85, on right: 82
bracket_set (84)
    on left: 86 87, on right: 85 86
expr_list_e (85)
    on left: 88 89, on right: 36 84
expr_list (86)
    on left: 90 91, on right: 88 90 97
atomic (87)
    on left: 92 93 94 95 96 97, on right: 83


State 0

    0 $accept: . program $end
    1 program: . decl_list
    2        | . %empty  [$end]
    3 decl_list: . decl_var decl_list
    4          | . decl_func decl_list
    5          | . decl_var
    6          | . decl_func
    7 decl_var: . IDENTIFIER COLON type_var SEMICOLON
    8         | . IDENTIFIER COLON type_var EQUALS expr_10 SEMICOLON
    9 decl_func: . IDENTIFIER COLON FUNCTION type_func OPEN_PAREN param_list_e CLOSE_PAREN EQUALS OPEN_CURLY stmt_list CLOSE_CURLY
   10          | . IDENTIFIER COLON FUNCTION type_func OPEN_PAREN param_list_e CLOSE_PAREN SEMICOLON

    IDENTIFIER  shift, and go to state 1

    $default  reduce using rule 2 (program)

    program    go to state 2
    decl_list  go to state 3
    decl_var   go to state 4
    decl_func  go to state 5


State 1

    7 decl_var: IDENTIFIER . COLON type_var SEMICOLON
    8         | IDENTIFIER . COLON type_var EQUALS expr_10 SEMICOLON
    9 decl_func: IDENTIFIER . COLON FUNCTION type_func OPEN_PAREN param_list_e CLOSE_PAREN EQUALS OPEN_CURLY stmt_list CLOSE_CURLY
   10          | IDENTIFIER . COLON FUNCTION type_func OPEN_PAREN param_list_e CLOSE_PAREN SEMICOLON

    COLON  shift, and go to state 6


State 2

    0 $accept: program . $end

    $end  shift, and go to state 7


State 3

    1 program: decl_list .

    $default  reduce using rule 1 (program)


State 4

    3 decl_list: . decl_var decl_list
    3          | decl_var . decl_list
    4          | . decl_func decl_list
    5          | . decl_var
    5          | decl_var .  [$end]
    6          | . decl_func
    7 decl_var: . IDENTIFIER COLON type_var SEMICOLON
    8         | . IDENTIFIER COLON type_var EQUALS expr_10 SEMICOLON
    9 decl_func: . IDENTIFIER COLON FUNCTION type_func OPEN_PAREN param_list_e CLOSE_PAREN EQUALS OPEN_CURLY stmt_list CLOSE_CURLY
   10          | . IDENTIFIER COLON FUNCTION type_func OPEN_PAREN param_list_e CLOSE_PAREN SEMICOLON

    IDENTIFIER  shift, and go to state 1

    $default  reduce using rule 5 (decl_list)

    decl_list  go to state 8
    decl_var   go to state 4
    decl_func  go to state 5


State 5

    3 decl_list: . decl_var decl_list
    4          | . decl_func decl_list
    4          | decl_func . decl_list
    5          | . decl_var
    6          | . decl_func
    6          | decl_func .  [$end]
    7 decl_var: . IDENTIFIER COLON type_var SEMICOLON
    8         | . IDENTIFIER COLON type_var EQUALS expr_10 SEMICOLON
    9 decl_func: . IDENTIFIER COLON FUNCTION type_func OPEN_PAREN param_list_e CLOSE_PAREN EQUALS OPEN_CURLY stmt_list CLOSE_CURLY
   10          | . IDENTIFIER COLON FUNCTION type_func OPEN_PAREN param_list_e CLOSE_PAREN SEMICOLON

    IDENTIFIER  shift, and go to state 1

    $default  reduce using rule 6 (decl_list)

    decl_list  go to state 9
    decl_var   go to state 4
    decl_func  go to state 5


State 6

    7 decl_var: IDENTIFIER COLON . type_var SEMICOLON
    8         | IDENTIFIER COLON . type_var EQUALS expr_10 SEMICOLON
    9 decl_func: IDENTIFIER COLON . FUNCTION type_func OPEN_PAREN param_list_e CLOSE_PAREN EQUALS OPEN_CURLY stmt_list CLOSE_CURLY
   10          | IDENTIFIER COLON . FUNCTION type_func OPEN_PAREN param_list_e CLOSE_PAREN SEMICOLON
   27 type_var: . INTEGER
   28         | . BOOLEAN
   29         | . CHAR
   30         | . STRING
   31         | . AUTO
   32         | . ARRAY OPEN_SQUARE expr_10 CLOSE_SQUARE type_var

    ARRAY     shift, and go to state 10
    AUTO      shift, and go to state 11
    BOOLEAN   shift, and go to state 12
    CHAR      shift, and go to state 13
    FUNCTION  shift, and go to state 14
    INTEGER   shift, and go to state 15
    STRING    shift, and go to state 16

    type_var  go to state 17


State 7

    0 $accept: program $end .

    $default  accept


State 8

    3 decl_list: decl_var decl_list .

    $default  reduce using rule 3 (decl_list)


State 9

    4 decl_list: decl_func decl_list .

    $default  reduce using rule 4 (decl_list)


State 10

   32 type_var: ARRAY . OPEN_SQUARE expr_10 CLOSE_SQUARE type_var

    OPEN_SQUARE  shift, and go to state 18


State 11

   31 type_var: AUTO .

    $default  reduce using rule 31 (type_var)


State 12

   28 type_var: BOOLEAN .

    $default  reduce using rule 28 (type_var)


State 13

   29 type_var: CHAR .

    $default  reduce using rule 29 (type_var)


State 14

    9 decl_func: IDENTIFIER COLON FUNCTION . type_func OPEN_PAREN param_list_e CLOSE_PAREN EQUALS OPEN_CURLY stmt_list CLOSE_CURLY
   10          | IDENTIFIER COLON FUNCTION . type_func OPEN_PAREN param_list_e CLOSE_PAREN SEMICOLON
   11 type_func: . INTEGER
   12          | . BOOLEAN
   13          | . CHAR
   14          | . STRING
   15          | . VOID

    BOOLEAN  shift, and go to state 19
    CHAR     shift, and go to state 20
    INTEGER  shift, and go to state 21
    STRING   shift, and go to state 22
    VOID     shift, and go to state 23

    type_func  go to state 24


State 15

   27 type_var: INTEGER .

    $default  reduce using rule 27 (type_var)


State 16

   30 type_var: STRING .

    $default  reduce using rule 30 (type_var)


State 17

    7 decl_var: IDENTIFIER COLON type_var . SEMICOLON
    8         | IDENTIFIER COLON type_var . EQUALS expr_10 SEMICOLON

    SEMICOLON  shift, and go to state 25
    EQUALS     shift, and go to state 26


State 18

   32 type_var: ARRAY OPEN_SQUARE . expr_10 CLOSE_SQUARE type_var
   51 expr_10: . expr_9 EQUALS expr_10
   52        | . expr_9 QUESTION expr_10 COLON expr_10
   53        | . expr_9
   54 expr_9: . expr_9 OR expr_8
   55       | . expr_8
   56 expr_8: . expr_8 AND expr_7
   57       | . expr_7
   58 expr_7: . expr_7 LT expr_6
   59       | . expr_7 LE expr_6
   60       | . expr_7 EE expr_6
   61       | . expr_7 GE expr_6
   62       | . expr_7 GT expr_6
   63       | . expr_7 NE expr_6
   64       | . expr_6
   65 expr_6: . expr_6 PLUS expr_5
   66       | . expr_6 MINUS expr_5
   67       | . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    expr_10          go to state 36
    expr_9           go to state 37
    expr_8           go to state 38
    expr_7           go to state 39
    expr_6           go to state 40
    expr_5           go to state 41
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 19

   12 type_func: BOOLEAN .

    $default  reduce using rule 12 (type_func)


State 20

   13 type_func: CHAR .

    $default  reduce using rule 13 (type_func)


State 21

   11 type_func: INTEGER .

    $default  reduce using rule 11 (type_func)


State 22

   14 type_func: STRING .

    $default  reduce using rule 14 (type_func)


State 23

   15 type_func: VOID .

    $default  reduce using rule 15 (type_func)


State 24

    9 decl_func: IDENTIFIER COLON FUNCTION type_func . OPEN_PAREN param_list_e CLOSE_PAREN EQUALS OPEN_CURLY stmt_list CLOSE_CURLY
   10          | IDENTIFIER COLON FUNCTION type_func . OPEN_PAREN param_list_e CLOSE_PAREN SEMICOLON

    OPEN_PAREN  shift, and go to state 49


State 25

    7 decl_var: IDENTIFIER COLON type_var SEMICOLON .

    $default  reduce using rule 7 (decl_var)


State 26

    8 decl_var: IDENTIFIER COLON type_var EQUALS . expr_10 SEMICOLON
   51 expr_10: . expr_9 EQUALS expr_10
   52        | . expr_9 QUESTION expr_10 COLON expr_10
   53        | . expr_9
   54 expr_9: . expr_9 OR expr_8
   55       | . expr_8
   56 expr_8: . expr_8 AND expr_7
   57       | . expr_7
   58 expr_7: . expr_7 LT expr_6
   59       | . expr_7 LE expr_6
   60       | . expr_7 EE expr_6
   61       | . expr_7 GE expr_6
   62       | . expr_7 GT expr_6
   63       | . expr_7 NE expr_6
   64       | . expr_6
   65 expr_6: . expr_6 PLUS expr_5
   66       | . expr_6 MINUS expr_5
   67       | . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    expr_10          go to state 50
    expr_9           go to state 37
    expr_8           go to state 38
    expr_7           go to state 39
    expr_6           go to state 40
    expr_5           go to state 41
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 27

   92 atomic: INTEGER_LITERAL .

    $default  reduce using rule 92 (atomic)


State 28

   93 atomic: BOOLEAN_LITERAL .

    $default  reduce using rule 93 (atomic)


State 29

   94 atomic: CHAR_LITERAL .

    $default  reduce using rule 94 (atomic)


State 30

   95 atomic: STRING_LITERAL .

    $default  reduce using rule 95 (atomic)


State 31

   84 func_call: IDENTIFIER . OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: IDENTIFIER . bracket_set
   86 bracket_set: . OPEN_SQUARE expr_10 CLOSE_SQUARE bracket_set
   87            | . OPEN_SQUARE expr_10 CLOSE_SQUARE
   96 atomic: IDENTIFIER .  [SEMICOLON, COLON, QUESTION, EQUALS, GT, GE, LT, LE, EE, NE, AND, OR, INCREMENT, DECREMENT, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, PLUS, MINUS, MULTIPLY, DIVIDE, REMAINDER, EXP, COMMA]

    OPEN_PAREN   shift, and go to state 51
    OPEN_SQUARE  shift, and go to state 52

    $default  reduce using rule 96 (atomic)

    bracket_set  go to state 53


State 32

   51 expr_10: . expr_9 EQUALS expr_10
   52        | . expr_9 QUESTION expr_10 COLON expr_10
   53        | . expr_9
   54 expr_9: . expr_9 OR expr_8
   55       | . expr_8
   56 expr_8: . expr_8 AND expr_7
   57       | . expr_7
   58 expr_7: . expr_7 LT expr_6
   59       | . expr_7 LE expr_6
   60       | . expr_7 EE expr_6
   61       | . expr_7 GE expr_6
   62       | . expr_7 GT expr_6
   63       | . expr_7 NE expr_6
   64       | . expr_6
   65 expr_6: . expr_6 PLUS expr_5
   66       | . expr_6 MINUS expr_5
   67       | . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   80       | OPEN_PAREN . expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    expr_10          go to state 54
    expr_9           go to state 37
    expr_8           go to state 38
    expr_7           go to state 39
    expr_6           go to state 40
    expr_5           go to state 41
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 33

   51 expr_10: . expr_9 EQUALS expr_10
   52        | . expr_9 QUESTION expr_10 COLON expr_10
   53        | . expr_9
   54 expr_9: . expr_9 OR expr_8
   55       | . expr_8
   56 expr_8: . expr_8 AND expr_7
   57       | . expr_7
   58 expr_7: . expr_7 LT expr_6
   59       | . expr_7 LE expr_6
   60       | . expr_7 EE expr_6
   61       | . expr_7 GE expr_6
   62       | . expr_7 GT expr_6
   63       | . expr_7 NE expr_6
   64       | . expr_6
   65 expr_6: . expr_6 PLUS expr_5
   66       | . expr_6 MINUS expr_5
   67       | . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   90 expr_list: . expr_10 COMMA expr_list
   91          | . expr_10
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY
   97       | OPEN_CURLY . expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    expr_10          go to state 55
    expr_9           go to state 37
    expr_8           go to state 38
    expr_7           go to state 39
    expr_6           go to state 40
    expr_5           go to state 41
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    expr_list        go to state 56
    atomic           go to state 48


State 34

   74 expr_3: . MINUS expr_3
   74       | MINUS . expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    expr_3           go to state 57
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 35

   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   75       | NOT . expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    expr_3           go to state 58
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 36

   32 type_var: ARRAY OPEN_SQUARE expr_10 . CLOSE_SQUARE type_var

    CLOSE_SQUARE  shift, and go to state 59


State 37

   51 expr_10: expr_9 . EQUALS expr_10
   52        | expr_9 . QUESTION expr_10 COLON expr_10
   53        | expr_9 .  [SEMICOLON, COLON, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, COMMA]
   54 expr_9: expr_9 . OR expr_8

    QUESTION  shift, and go to state 60
    EQUALS    shift, and go to state 61
    OR        shift, and go to state 62

    $default  reduce using rule 53 (expr_10)


State 38

   55 expr_9: expr_8 .  [SEMICOLON, COLON, QUESTION, EQUALS, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, COMMA]
   56 expr_8: expr_8 . AND expr_7

    AND  shift, and go to state 63

    $default  reduce using rule 55 (expr_9)


State 39

   57 expr_8: expr_7 .  [SEMICOLON, COLON, QUESTION, EQUALS, AND, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, COMMA]
   58 expr_7: expr_7 . LT expr_6
   59       | expr_7 . LE expr_6
   60       | expr_7 . EE expr_6
   61       | expr_7 . GE expr_6
   62       | expr_7 . GT expr_6
   63       | expr_7 . NE expr_6

    GT  shift, and go to state 64
    GE  shift, and go to state 65
    LT  shift, and go to state 66
    LE  shift, and go to state 67
    EE  shift, and go to state 68
    NE  shift, and go to state 69

    $default  reduce using rule 57 (expr_8)


State 40

   64 expr_7: expr_6 .  [SEMICOLON, COLON, QUESTION, EQUALS, GT, GE, LT, LE, EE, NE, AND, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, COMMA]
   65 expr_6: expr_6 . PLUS expr_5
   66       | expr_6 . MINUS expr_5

    PLUS   shift, and go to state 70
    MINUS  shift, and go to state 71

    $default  reduce using rule 64 (expr_7)


State 41

   67 expr_6: expr_5 .  [SEMICOLON, COLON, QUESTION, EQUALS, GT, GE, LT, LE, EE, NE, AND, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, PLUS, MINUS, COMMA]
   68 expr_5: expr_5 . MULTIPLY expr_4
   69       | expr_5 . DIVIDE expr_4
   70       | expr_5 . REMAINDER expr_4

    MULTIPLY   shift, and go to state 72
    DIVIDE     shift, and go to state 73
    REMAINDER  shift, and go to state 74

    $default  reduce using rule 67 (expr_6)


State 42

   71 expr_5: expr_4 .

    $default  reduce using rule 71 (expr_5)


State 43

   72 expr_4: expr_3 . EXP expr_4
   73       | expr_3 .  [SEMICOLON, COLON, QUESTION, EQUALS, GT, GE, LT, LE, EE, NE, AND, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, PLUS, MINUS, MULTIPLY, DIVIDE, REMAINDER, COMMA]

    EXP  shift, and go to state 75

    $default  reduce using rule 73 (expr_4)


State 44

   76 expr_3: expr_2 .  [SEMICOLON, COLON, QUESTION, EQUALS, GT, GE, LT, LE, EE, NE, AND, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, PLUS, MINUS, MULTIPLY, DIVIDE, REMAINDER, EXP, COMMA]
   77 expr_2: expr_2 . INCREMENT
   78       | expr_2 . DECREMENT

    INCREMENT  shift, and go to state 76
    DECREMENT  shift, and go to state 77

    $default  reduce using rule 76 (expr_3)


State 45

   79 expr_2: expr_1 .

    $default  reduce using rule 79 (expr_2)


State 46

   81 expr_1: func_call .

    $default  reduce using rule 81 (expr_1)


State 47

   82 expr_1: array_subscript .

    $default  reduce using rule 82 (expr_1)


State 48

   83 expr_1: atomic .

    $default  reduce using rule 83 (expr_1)


State 49

    9 decl_func: IDENTIFIER COLON FUNCTION type_func OPEN_PAREN . param_list_e CLOSE_PAREN EQUALS OPEN_CURLY stmt_list CLOSE_CURLY
   10          | IDENTIFIER COLON FUNCTION type_func OPEN_PAREN . param_list_e CLOSE_PAREN SEMICOLON
   16 param_list_e: . param_list
   17             | . %empty  [CLOSE_PAREN]
   18 param_list: . IDENTIFIER COLON type_param COMMA param_list
   19           | . IDENTIFIER COLON type_param

    IDENTIFIER  shift, and go to state 78

    $default  reduce using rule 17 (param_list_e)

    param_list_e  go to state 79
    param_list    go to state 80


State 50

    8 decl_var: IDENTIFIER COLON type_var EQUALS expr_10 . SEMICOLON

    SEMICOLON  shift, and go to state 81


State 51

   51 expr_10: . expr_9 EQUALS expr_10
   52        | . expr_9 QUESTION expr_10 COLON expr_10
   53        | . expr_9
   54 expr_9: . expr_9 OR expr_8
   55       | . expr_8
   56 expr_8: . expr_8 AND expr_7
   57       | . expr_7
   58 expr_7: . expr_7 LT expr_6
   59       | . expr_7 LE expr_6
   60       | . expr_7 EE expr_6
   61       | . expr_7 GE expr_6
   62       | . expr_7 GT expr_6
   63       | . expr_7 NE expr_6
   64       | . expr_6
   65 expr_6: . expr_6 PLUS expr_5
   66       | . expr_6 MINUS expr_5
   67       | . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   84          | IDENTIFIER OPEN_PAREN . expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   88 expr_list_e: . expr_list
   89            | . %empty  [CLOSE_PAREN]
   90 expr_list: . expr_10 COMMA expr_list
   91          | . expr_10
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    $default  reduce using rule 89 (expr_list_e)

    expr_10          go to state 55
    expr_9           go to state 37
    expr_8           go to state 38
    expr_7           go to state 39
    expr_6           go to state 40
    expr_5           go to state 41
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    expr_list_e      go to state 82
    expr_list        go to state 83
    atomic           go to state 48


State 52

   51 expr_10: . expr_9 EQUALS expr_10
   52        | . expr_9 QUESTION expr_10 COLON expr_10
   53        | . expr_9
   54 expr_9: . expr_9 OR expr_8
   55       | . expr_8
   56 expr_8: . expr_8 AND expr_7
   57       | . expr_7
   58 expr_7: . expr_7 LT expr_6
   59       | . expr_7 LE expr_6
   60       | . expr_7 EE expr_6
   61       | . expr_7 GE expr_6
   62       | . expr_7 GT expr_6
   63       | . expr_7 NE expr_6
   64       | . expr_6
   65 expr_6: . expr_6 PLUS expr_5
   66       | . expr_6 MINUS expr_5
   67       | . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   86 bracket_set: OPEN_SQUARE . expr_10 CLOSE_SQUARE bracket_set
   87            | OPEN_SQUARE . expr_10 CLOSE_SQUARE
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    expr_10          go to state 84
    expr_9           go to state 37
    expr_8           go to state 38
    expr_7           go to state 39
    expr_6           go to state 40
    expr_5           go to state 41
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 53

   85 array_subscript: IDENTIFIER bracket_set .

    $default  reduce using rule 85 (array_subscript)


State 54

   80 expr_1: OPEN_PAREN expr_10 . CLOSE_PAREN

    CLOSE_PAREN  shift, and go to state 85


State 55

   90 expr_list: expr_10 . COMMA expr_list
   91          | expr_10 .  [SEMICOLON, CLOSE_PAREN, CLOSE_CURLY]

    COMMA  shift, and go to state 86

    $default  reduce using rule 91 (expr_list)


State 56

   97 atomic: OPEN_CURLY expr_list . CLOSE_CURLY

    CLOSE_CURLY  shift, and go to state 87


State 57

   74 expr_3: MINUS expr_3 .

    $default  reduce using rule 74 (expr_3)


State 58

   75 expr_3: NOT expr_3 .

    $default  reduce using rule 75 (expr_3)


State 59

   27 type_var: . INTEGER
   28         | . BOOLEAN
   29         | . CHAR
   30         | . STRING
   31         | . AUTO
   32         | . ARRAY OPEN_SQUARE expr_10 CLOSE_SQUARE type_var
   32         | ARRAY OPEN_SQUARE expr_10 CLOSE_SQUARE . type_var

    ARRAY    shift, and go to state 10
    AUTO     shift, and go to state 11
    BOOLEAN  shift, and go to state 12
    CHAR     shift, and go to state 13
    INTEGER  shift, and go to state 15
    STRING   shift, and go to state 16

    type_var  go to state 88


State 60

   51 expr_10: . expr_9 EQUALS expr_10
   52        | . expr_9 QUESTION expr_10 COLON expr_10
   52        | expr_9 QUESTION . expr_10 COLON expr_10
   53        | . expr_9
   54 expr_9: . expr_9 OR expr_8
   55       | . expr_8
   56 expr_8: . expr_8 AND expr_7
   57       | . expr_7
   58 expr_7: . expr_7 LT expr_6
   59       | . expr_7 LE expr_6
   60       | . expr_7 EE expr_6
   61       | . expr_7 GE expr_6
   62       | . expr_7 GT expr_6
   63       | . expr_7 NE expr_6
   64       | . expr_6
   65 expr_6: . expr_6 PLUS expr_5
   66       | . expr_6 MINUS expr_5
   67       | . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    expr_10          go to state 89
    expr_9           go to state 37
    expr_8           go to state 38
    expr_7           go to state 39
    expr_6           go to state 40
    expr_5           go to state 41
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 61

   51 expr_10: . expr_9 EQUALS expr_10
   51        | expr_9 EQUALS . expr_10
   52        | . expr_9 QUESTION expr_10 COLON expr_10
   53        | . expr_9
   54 expr_9: . expr_9 OR expr_8
   55       | . expr_8
   56 expr_8: . expr_8 AND expr_7
   57       | . expr_7
   58 expr_7: . expr_7 LT expr_6
   59       | . expr_7 LE expr_6
   60       | . expr_7 EE expr_6
   61       | . expr_7 GE expr_6
   62       | . expr_7 GT expr_6
   63       | . expr_7 NE expr_6
   64       | . expr_6
   65 expr_6: . expr_6 PLUS expr_5
   66       | . expr_6 MINUS expr_5
   67       | . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    expr_10          go to state 90
    expr_9           go to state 37
    expr_8           go to state 38
    expr_7           go to state 39
    expr_6           go to state 40
    expr_5           go to state 41
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 62

   54 expr_9: expr_9 OR . expr_8
   56 expr_8: . expr_8 AND expr_7
   57       | . expr_7
   58 expr_7: . expr_7 LT expr_6
   59       | . expr_7 LE expr_6
   60       | . expr_7 EE expr_6
   61       | . expr_7 GE expr_6
   62       | . expr_7 GT expr_6
   63       | . expr_7 NE expr_6
   64       | . expr_6
   65 expr_6: . expr_6 PLUS expr_5
   66       | . expr_6 MINUS expr_5
   67       | . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    expr_8           go to state 91
    expr_7           go to state 39
    expr_6           go to state 40
    expr_5           go to state 41
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 63

   56 expr_8: expr_8 AND . expr_7
   58 expr_7: . expr_7 LT expr_6
   59       | . expr_7 LE expr_6
   60       | . expr_7 EE expr_6
   61       | . expr_7 GE expr_6
   62       | . expr_7 GT expr_6
   63       | . expr_7 NE expr_6
   64       | . expr_6
   65 expr_6: . expr_6 PLUS expr_5
   66       | . expr_6 MINUS expr_5
   67       | . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    expr_7           go to state 92
    expr_6           go to state 40
    expr_5           go to state 41
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 64

   62 expr_7: expr_7 GT . expr_6
   65 expr_6: . expr_6 PLUS expr_5
   66       | . expr_6 MINUS expr_5
   67       | . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    expr_6           go to state 93
    expr_5           go to state 41
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 65

   61 expr_7: expr_7 GE . expr_6
   65 expr_6: . expr_6 PLUS expr_5
   66       | . expr_6 MINUS expr_5
   67       | . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    expr_6           go to state 94
    expr_5           go to state 41
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 66

   58 expr_7: expr_7 LT . expr_6
   65 expr_6: . expr_6 PLUS expr_5
   66       | . expr_6 MINUS expr_5
   67       | . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    expr_6           go to state 95
    expr_5           go to state 41
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 67

   59 expr_7: expr_7 LE . expr_6
   65 expr_6: . expr_6 PLUS expr_5
   66       | . expr_6 MINUS expr_5
   67       | . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    expr_6           go to state 96
    expr_5           go to state 41
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 68

   60 expr_7: expr_7 EE . expr_6
   65 expr_6: . expr_6 PLUS expr_5
   66       | . expr_6 MINUS expr_5
   67       | . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    expr_6           go to state 97
    expr_5           go to state 41
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 69

   63 expr_7: expr_7 NE . expr_6
   65 expr_6: . expr_6 PLUS expr_5
   66       | . expr_6 MINUS expr_5
   67       | . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    expr_6           go to state 98
    expr_5           go to state 41
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 70

   65 expr_6: expr_6 PLUS . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    expr_5           go to state 99
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 71

   66 expr_6: expr_6 MINUS . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    expr_5           go to state 100
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 72

   68 expr_5: expr_5 MULTIPLY . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    expr_4           go to state 101
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 73

   69 expr_5: expr_5 DIVIDE . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    expr_4           go to state 102
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 74

   70 expr_5: expr_5 REMAINDER . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    expr_4           go to state 103
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 75

   72 expr_4: . expr_3 EXP expr_4
   72       | expr_3 EXP . expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    expr_4           go to state 104
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 76

   77 expr_2: expr_2 INCREMENT .

    $default  reduce using rule 77 (expr_2)


State 77

   78 expr_2: expr_2 DECREMENT .

    $default  reduce using rule 78 (expr_2)


State 78

   18 param_list: IDENTIFIER . COLON type_param COMMA param_list
   19           | IDENTIFIER . COLON type_param

    COLON  shift, and go to state 105


State 79

    9 decl_func: IDENTIFIER COLON FUNCTION type_func OPEN_PAREN param_list_e . CLOSE_PAREN EQUALS OPEN_CURLY stmt_list CLOSE_CURLY
   10          | IDENTIFIER COLON FUNCTION type_func OPEN_PAREN param_list_e . CLOSE_PAREN SEMICOLON

    CLOSE_PAREN  shift, and go to state 106


State 80

   16 param_list_e: param_list .

    $default  reduce using rule 16 (param_list_e)


State 81

    8 decl_var: IDENTIFIER COLON type_var EQUALS expr_10 SEMICOLON .

    $default  reduce using rule 8 (decl_var)


State 82

   84 func_call: IDENTIFIER OPEN_PAREN expr_list_e . CLOSE_PAREN

    CLOSE_PAREN  shift, and go to state 107


State 83

   88 expr_list_e: expr_list .

    $default  reduce using rule 88 (expr_list_e)


State 84

   86 bracket_set: OPEN_SQUARE expr_10 . CLOSE_SQUARE bracket_set
   87            | OPEN_SQUARE expr_10 . CLOSE_SQUARE

    CLOSE_SQUARE  shift, and go to state 108


State 85

   80 expr_1: OPEN_PAREN expr_10 CLOSE_PAREN .

    $default  reduce using rule 80 (expr_1)


State 86

   51 expr_10: . expr_9 EQUALS expr_10
   52        | . expr_9 QUESTION expr_10 COLON expr_10
   53        | . expr_9
   54 expr_9: . expr_9 OR expr_8
   55       | . expr_8
   56 expr_8: . expr_8 AND expr_7
   57       | . expr_7
   58 expr_7: . expr_7 LT expr_6
   59       | . expr_7 LE expr_6
   60       | . expr_7 EE expr_6
   61       | . expr_7 GE expr_6
   62       | . expr_7 GT expr_6
   63       | . expr_7 NE expr_6
   64       | . expr_6
   65 expr_6: . expr_6 PLUS expr_5
   66       | . expr_6 MINUS expr_5
   67       | . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   90 expr_list: . expr_10 COMMA expr_list
   90          | expr_10 COMMA . expr_list
   91          | . expr_10
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    expr_10          go to state 55
    expr_9           go to state 37
    expr_8           go to state 38
    expr_7           go to state 39
    expr_6           go to state 40
    expr_5           go to state 41
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    expr_list        go to state 109
    atomic           go to state 48


State 87

   97 atomic: OPEN_CURLY expr_list CLOSE_CURLY .

    $default  reduce using rule 97 (atomic)


State 88

   32 type_var: ARRAY OPEN_SQUARE expr_10 CLOSE_SQUARE type_var .

    $default  reduce using rule 32 (type_var)


State 89

   52 expr_10: expr_9 QUESTION expr_10 . COLON expr_10

    COLON  shift, and go to state 110


State 90

   51 expr_10: expr_9 EQUALS expr_10 .

    $default  reduce using rule 51 (expr_10)


State 91

   54 expr_9: expr_9 OR expr_8 .  [SEMICOLON, COLON, QUESTION, EQUALS, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, COMMA]
   56 expr_8: expr_8 . AND expr_7

    AND  shift, and go to state 63

    $default  reduce using rule 54 (expr_9)


State 92

   56 expr_8: expr_8 AND expr_7 .  [SEMICOLON, COLON, QUESTION, EQUALS, AND, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, COMMA]
   58 expr_7: expr_7 . LT expr_6
   59       | expr_7 . LE expr_6
   60       | expr_7 . EE expr_6
   61       | expr_7 . GE expr_6
   62       | expr_7 . GT expr_6
   63       | expr_7 . NE expr_6

    GT  shift, and go to state 64
    GE  shift, and go to state 65
    LT  shift, and go to state 66
    LE  shift, and go to state 67
    EE  shift, and go to state 68
    NE  shift, and go to state 69

    $default  reduce using rule 56 (expr_8)


State 93

   62 expr_7: expr_7 GT expr_6 .  [SEMICOLON, COLON, QUESTION, EQUALS, GT, GE, LT, LE, EE, NE, AND, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, COMMA]
   65 expr_6: expr_6 . PLUS expr_5
   66       | expr_6 . MINUS expr_5

    PLUS   shift, and go to state 70
    MINUS  shift, and go to state 71

    $default  reduce using rule 62 (expr_7)


State 94

   61 expr_7: expr_7 GE expr_6 .  [SEMICOLON, COLON, QUESTION, EQUALS, GT, GE, LT, LE, EE, NE, AND, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, COMMA]
   65 expr_6: expr_6 . PLUS expr_5
   66       | expr_6 . MINUS expr_5

    PLUS   shift, and go to state 70
    MINUS  shift, and go to state 71

    $default  reduce using rule 61 (expr_7)


State 95

   58 expr_7: expr_7 LT expr_6 .  [SEMICOLON, COLON, QUESTION, EQUALS, GT, GE, LT, LE, EE, NE, AND, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, COMMA]
   65 expr_6: expr_6 . PLUS expr_5
   66       | expr_6 . MINUS expr_5

    PLUS   shift, and go to state 70
    MINUS  shift, and go to state 71

    $default  reduce using rule 58 (expr_7)


State 96

   59 expr_7: expr_7 LE expr_6 .  [SEMICOLON, COLON, QUESTION, EQUALS, GT, GE, LT, LE, EE, NE, AND, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, COMMA]
   65 expr_6: expr_6 . PLUS expr_5
   66       | expr_6 . MINUS expr_5

    PLUS   shift, and go to state 70
    MINUS  shift, and go to state 71

    $default  reduce using rule 59 (expr_7)


State 97

   60 expr_7: expr_7 EE expr_6 .  [SEMICOLON, COLON, QUESTION, EQUALS, GT, GE, LT, LE, EE, NE, AND, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, COMMA]
   65 expr_6: expr_6 . PLUS expr_5
   66       | expr_6 . MINUS expr_5

    PLUS   shift, and go to state 70
    MINUS  shift, and go to state 71

    $default  reduce using rule 60 (expr_7)


State 98

   63 expr_7: expr_7 NE expr_6 .  [SEMICOLON, COLON, QUESTION, EQUALS, GT, GE, LT, LE, EE, NE, AND, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, COMMA]
   65 expr_6: expr_6 . PLUS expr_5
   66       | expr_6 . MINUS expr_5

    PLUS   shift, and go to state 70
    MINUS  shift, and go to state 71

    $default  reduce using rule 63 (expr_7)


State 99

   65 expr_6: expr_6 PLUS expr_5 .  [SEMICOLON, COLON, QUESTION, EQUALS, GT, GE, LT, LE, EE, NE, AND, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, PLUS, MINUS, COMMA]
   68 expr_5: expr_5 . MULTIPLY expr_4
   69       | expr_5 . DIVIDE expr_4
   70       | expr_5 . REMAINDER expr_4

    MULTIPLY   shift, and go to state 72
    DIVIDE     shift, and go to state 73
    REMAINDER  shift, and go to state 74

    $default  reduce using rule 65 (expr_6)


State 100

   66 expr_6: expr_6 MINUS expr_5 .  [SEMICOLON, COLON, QUESTION, EQUALS, GT, GE, LT, LE, EE, NE, AND, OR, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, PLUS, MINUS, COMMA]
   68 expr_5: expr_5 . MULTIPLY expr_4
   69       | expr_5 . DIVIDE expr_4
   70       | expr_5 . REMAINDER expr_4

    MULTIPLY   shift, and go to state 72
    DIVIDE     shift, and go to state 73
    REMAINDER  shift, and go to state 74

    $default  reduce using rule 66 (expr_6)


State 101

   68 expr_5: expr_5 MULTIPLY expr_4 .

    $default  reduce using rule 68 (expr_5)


State 102

   69 expr_5: expr_5 DIVIDE expr_4 .

    $default  reduce using rule 69 (expr_5)


State 103

   70 expr_5: expr_5 REMAINDER expr_4 .

    $default  reduce using rule 70 (expr_5)


State 104

   72 expr_4: expr_3 EXP expr_4 .

    $default  reduce using rule 72 (expr_4)


State 105

   18 param_list: IDENTIFIER COLON . type_param COMMA param_list
   19           | IDENTIFIER COLON . type_param
   20 type_param: . INTEGER
   21           | . BOOLEAN
   22           | . CHAR
   23           | . STRING
   24           | . AUTO
   25           | . ARRAY OPEN_SQUARE expr_10 CLOSE_SQUARE type_param
   26           | . ARRAY OPEN_SQUARE CLOSE_SQUARE type_param

    ARRAY    shift, and go to state 111
    AUTO     shift, and go to state 112
    BOOLEAN  shift, and go to state 113
    CHAR     shift, and go to state 114
    INTEGER  shift, and go to state 115
    STRING   shift, and go to state 116

    type_param  go to state 117


State 106

    9 decl_func: IDENTIFIER COLON FUNCTION type_func OPEN_PAREN param_list_e CLOSE_PAREN . EQUALS OPEN_CURLY stmt_list CLOSE_CURLY
   10          | IDENTIFIER COLON FUNCTION type_func OPEN_PAREN param_list_e CLOSE_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 118
    EQUALS     shift, and go to state 119


State 107

   84 func_call: IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN .

    $default  reduce using rule 84 (func_call)


State 108

   86 bracket_set: . OPEN_SQUARE expr_10 CLOSE_SQUARE bracket_set
   86            | OPEN_SQUARE expr_10 CLOSE_SQUARE . bracket_set
   87            | . OPEN_SQUARE expr_10 CLOSE_SQUARE
   87            | OPEN_SQUARE expr_10 CLOSE_SQUARE .  [SEMICOLON, COLON, QUESTION, EQUALS, GT, GE, LT, LE, EE, NE, AND, OR, INCREMENT, DECREMENT, CLOSE_PAREN, CLOSE_SQUARE, CLOSE_CURLY, PLUS, MINUS, MULTIPLY, DIVIDE, REMAINDER, EXP, COMMA]

    OPEN_SQUARE  shift, and go to state 52

    $default  reduce using rule 87 (bracket_set)

    bracket_set  go to state 120


State 109

   90 expr_list: expr_10 COMMA expr_list .

    $default  reduce using rule 90 (expr_list)


State 110

   51 expr_10: . expr_9 EQUALS expr_10
   52        | . expr_9 QUESTION expr_10 COLON expr_10
   52        | expr_9 QUESTION expr_10 COLON . expr_10
   53        | . expr_9
   54 expr_9: . expr_9 OR expr_8
   55       | . expr_8
   56 expr_8: . expr_8 AND expr_7
   57       | . expr_7
   58 expr_7: . expr_7 LT expr_6
   59       | . expr_7 LE expr_6
   60       | . expr_7 EE expr_6
   61       | . expr_7 GE expr_6
   62       | . expr_7 GT expr_6
   63       | . expr_7 NE expr_6
   64       | . expr_6
   65 expr_6: . expr_6 PLUS expr_5
   66       | . expr_6 MINUS expr_5
   67       | . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    expr_10          go to state 121
    expr_9           go to state 37
    expr_8           go to state 38
    expr_7           go to state 39
    expr_6           go to state 40
    expr_5           go to state 41
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 111

   25 type_param: ARRAY . OPEN_SQUARE expr_10 CLOSE_SQUARE type_param
   26           | ARRAY . OPEN_SQUARE CLOSE_SQUARE type_param

    OPEN_SQUARE  shift, and go to state 122


State 112

   24 type_param: AUTO .

    $default  reduce using rule 24 (type_param)


State 113

   21 type_param: BOOLEAN .

    $default  reduce using rule 21 (type_param)


State 114

   22 type_param: CHAR .

    $default  reduce using rule 22 (type_param)


State 115

   20 type_param: INTEGER .

    $default  reduce using rule 20 (type_param)


State 116

   23 type_param: STRING .

    $default  reduce using rule 23 (type_param)


State 117

   18 param_list: IDENTIFIER COLON type_param . COMMA param_list
   19           | IDENTIFIER COLON type_param .  [CLOSE_PAREN]

    COMMA  shift, and go to state 123

    $default  reduce using rule 19 (param_list)


State 118

   10 decl_func: IDENTIFIER COLON FUNCTION type_func OPEN_PAREN param_list_e CLOSE_PAREN SEMICOLON .

    $default  reduce using rule 10 (decl_func)


State 119

    9 decl_func: IDENTIFIER COLON FUNCTION type_func OPEN_PAREN param_list_e CLOSE_PAREN EQUALS . OPEN_CURLY stmt_list CLOSE_CURLY

    OPEN_CURLY  shift, and go to state 124


State 120

   86 bracket_set: OPEN_SQUARE expr_10 CLOSE_SQUARE bracket_set .

    $default  reduce using rule 86 (bracket_set)


State 121

   52 expr_10: expr_9 QUESTION expr_10 COLON expr_10 .

    $default  reduce using rule 52 (expr_10)


State 122

   25 type_param: ARRAY OPEN_SQUARE . expr_10 CLOSE_SQUARE type_param
   26           | ARRAY OPEN_SQUARE . CLOSE_SQUARE type_param
   51 expr_10: . expr_9 EQUALS expr_10
   52        | . expr_9 QUESTION expr_10 COLON expr_10
   53        | . expr_9
   54 expr_9: . expr_9 OR expr_8
   55       | . expr_8
   56 expr_8: . expr_8 AND expr_7
   57       | . expr_7
   58 expr_7: . expr_7 LT expr_6
   59       | . expr_7 LE expr_6
   60       | . expr_7 EE expr_6
   61       | . expr_7 GE expr_6
   62       | . expr_7 GT expr_6
   63       | . expr_7 NE expr_6
   64       | . expr_6
   65 expr_6: . expr_6 PLUS expr_5
   66       | . expr_6 MINUS expr_5
   67       | . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    CLOSE_SQUARE     shift, and go to state 125
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    expr_10          go to state 126
    expr_9           go to state 37
    expr_8           go to state 38
    expr_7           go to state 39
    expr_6           go to state 40
    expr_5           go to state 41
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 123

   18 param_list: . IDENTIFIER COLON type_param COMMA param_list
   18           | IDENTIFIER COLON type_param COMMA . param_list
   19           | . IDENTIFIER COLON type_param

    IDENTIFIER  shift, and go to state 78

    param_list  go to state 127


State 124

    7 decl_var: . IDENTIFIER COLON type_var SEMICOLON
    8         | . IDENTIFIER COLON type_var EQUALS expr_10 SEMICOLON
    9 decl_func: IDENTIFIER COLON FUNCTION type_func OPEN_PAREN param_list_e CLOSE_PAREN EQUALS OPEN_CURLY . stmt_list CLOSE_CURLY
   33 stmt: . if_stmt
   34 other_stmt: . RETURN expr_10 SEMICOLON
   35           | . RETURN SEMICOLON
   36           | . PRINT expr_list_e SEMICOLON
   37           | . OPEN_CURLY stmt_list CLOSE_CURLY
   38           | . expr_10 SEMICOLON
   39           | . FOR OPEN_PAREN expr_or_e SEMICOLON expr_or_e SEMICOLON expr_or_e CLOSE_PAREN stmt
   40           | . decl_var
   41 if_stmt: . matched_if_stmt
   42        | . open_if_stmt
   43 matched_if_stmt: . IF OPEN_PAREN expr_10 CLOSE_PAREN matched_if_stmt ELSE matched_if_stmt
   44                | . other_stmt
   45 open_if_stmt: . IF OPEN_PAREN expr_10 CLOSE_PAREN if_stmt
   46             | . IF OPEN_PAREN expr_10 CLOSE_PAREN matched_if_stmt ELSE open_if_stmt
   49 stmt_list: . stmt stmt_list
   50          | . stmt
   51 expr_10: . expr_9 EQUALS expr_10
   52        | . expr_9 QUESTION expr_10 COLON expr_10
   53        | . expr_9
   54 expr_9: . expr_9 OR expr_8
   55       | . expr_8
   56 expr_8: . expr_8 AND expr_7
   57       | . expr_7
   58 expr_7: . expr_7 LT expr_6
   59       | . expr_7 LE expr_6
   60       | . expr_7 EE expr_6
   61       | . expr_7 GE expr_6
   62       | . expr_7 GT expr_6
   63       | . expr_7 NE expr_6
   64       | . expr_6
   65 expr_6: . expr_6 PLUS expr_5
   66       | . expr_6 MINUS expr_5
   67       | . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    FOR              shift, and go to state 128
    IF               shift, and go to state 129
    PRINT            shift, and go to state 130
    RETURN           shift, and go to state 131
    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 132
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 133
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    decl_var         go to state 134
    stmt             go to state 135
    other_stmt       go to state 136
    if_stmt          go to state 137
    matched_if_stmt  go to state 138
    open_if_stmt     go to state 139
    stmt_list        go to state 140
    expr_10          go to state 141
    expr_9           go to state 37
    expr_8           go to state 38
    expr_7           go to state 39
    expr_6           go to state 40
    expr_5           go to state 41
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 125

   20 type_param: . INTEGER
   21           | . BOOLEAN
   22           | . CHAR
   23           | . STRING
   24           | . AUTO
   25           | . ARRAY OPEN_SQUARE expr_10 CLOSE_SQUARE type_param
   26           | . ARRAY OPEN_SQUARE CLOSE_SQUARE type_param
   26           | ARRAY OPEN_SQUARE CLOSE_SQUARE . type_param

    ARRAY    shift, and go to state 111
    AUTO     shift, and go to state 112
    BOOLEAN  shift, and go to state 113
    CHAR     shift, and go to state 114
    INTEGER  shift, and go to state 115
    STRING   shift, and go to state 116

    type_param  go to state 142


State 126

   25 type_param: ARRAY OPEN_SQUARE expr_10 . CLOSE_SQUARE type_param

    CLOSE_SQUARE  shift, and go to state 143


State 127

   18 param_list: IDENTIFIER COLON type_param COMMA param_list .

    $default  reduce using rule 18 (param_list)


State 128

   39 other_stmt: FOR . OPEN_PAREN expr_or_e SEMICOLON expr_or_e SEMICOLON expr_or_e CLOSE_PAREN stmt

    OPEN_PAREN  shift, and go to state 144


State 129

   43 matched_if_stmt: IF . OPEN_PAREN expr_10 CLOSE_PAREN matched_if_stmt ELSE matched_if_stmt
   45 open_if_stmt: IF . OPEN_PAREN expr_10 CLOSE_PAREN if_stmt
   46             | IF . OPEN_PAREN expr_10 CLOSE_PAREN matched_if_stmt ELSE open_if_stmt

    OPEN_PAREN  shift, and go to state 145


State 130

   36 other_stmt: PRINT . expr_list_e SEMICOLON
   51 expr_10: . expr_9 EQUALS expr_10
   52        | . expr_9 QUESTION expr_10 COLON expr_10
   53        | . expr_9
   54 expr_9: . expr_9 OR expr_8
   55       | . expr_8
   56 expr_8: . expr_8 AND expr_7
   57       | . expr_7
   58 expr_7: . expr_7 LT expr_6
   59       | . expr_7 LE expr_6
   60       | . expr_7 EE expr_6
   61       | . expr_7 GE expr_6
   62       | . expr_7 GT expr_6
   63       | . expr_7 NE expr_6
   64       | . expr_6
   65 expr_6: . expr_6 PLUS expr_5
   66       | . expr_6 MINUS expr_5
   67       | . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   88 expr_list_e: . expr_list
   89            | . %empty  [SEMICOLON]
   90 expr_list: . expr_10 COMMA expr_list
   91          | . expr_10
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    $default  reduce using rule 89 (expr_list_e)

    expr_10          go to state 55
    expr_9           go to state 37
    expr_8           go to state 38
    expr_7           go to state 39
    expr_6           go to state 40
    expr_5           go to state 41
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    expr_list_e      go to state 146
    expr_list        go to state 83
    atomic           go to state 48


State 131

   34 other_stmt: RETURN . expr_10 SEMICOLON
   35           | RETURN . SEMICOLON
   51 expr_10: . expr_9 EQUALS expr_10
   52        | . expr_9 QUESTION expr_10 COLON expr_10
   53        | . expr_9
   54 expr_9: . expr_9 OR expr_8
   55       | . expr_8
   56 expr_8: . expr_8 AND expr_7
   57       | . expr_7
   58 expr_7: . expr_7 LT expr_6
   59       | . expr_7 LE expr_6
   60       | . expr_7 EE expr_6
   61       | . expr_7 GE expr_6
   62       | . expr_7 GT expr_6
   63       | . expr_7 NE expr_6
   64       | . expr_6
   65 expr_6: . expr_6 PLUS expr_5
   66       | . expr_6 MINUS expr_5
   67       | . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    SEMICOLON        shift, and go to state 147
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    expr_10          go to state 148
    expr_9           go to state 37
    expr_8           go to state 38
    expr_7           go to state 39
    expr_6           go to state 40
    expr_5           go to state 41
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 132

    7 decl_var: IDENTIFIER . COLON type_var SEMICOLON
    8         | IDENTIFIER . COLON type_var EQUALS expr_10 SEMICOLON
   84 func_call: IDENTIFIER . OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: IDENTIFIER . bracket_set
   86 bracket_set: . OPEN_SQUARE expr_10 CLOSE_SQUARE bracket_set
   87            | . OPEN_SQUARE expr_10 CLOSE_SQUARE
   96 atomic: IDENTIFIER .  [SEMICOLON, QUESTION, EQUALS, GT, GE, LT, LE, EE, NE, AND, OR, INCREMENT, DECREMENT, CLOSE_CURLY, PLUS, MINUS, MULTIPLY, DIVIDE, REMAINDER, EXP, COMMA]

    COLON        shift, and go to state 149
    OPEN_PAREN   shift, and go to state 51
    OPEN_SQUARE  shift, and go to state 52

    $default  reduce using rule 96 (atomic)

    bracket_set  go to state 53


State 133

    7 decl_var: . IDENTIFIER COLON type_var SEMICOLON
    8         | . IDENTIFIER COLON type_var EQUALS expr_10 SEMICOLON
   33 stmt: . if_stmt
   34 other_stmt: . RETURN expr_10 SEMICOLON
   35           | . RETURN SEMICOLON
   36           | . PRINT expr_list_e SEMICOLON
   37           | . OPEN_CURLY stmt_list CLOSE_CURLY
   37           | OPEN_CURLY . stmt_list CLOSE_CURLY
   38           | . expr_10 SEMICOLON
   39           | . FOR OPEN_PAREN expr_or_e SEMICOLON expr_or_e SEMICOLON expr_or_e CLOSE_PAREN stmt
   40           | . decl_var
   41 if_stmt: . matched_if_stmt
   42        | . open_if_stmt
   43 matched_if_stmt: . IF OPEN_PAREN expr_10 CLOSE_PAREN matched_if_stmt ELSE matched_if_stmt
   44                | . other_stmt
   45 open_if_stmt: . IF OPEN_PAREN expr_10 CLOSE_PAREN if_stmt
   46             | . IF OPEN_PAREN expr_10 CLOSE_PAREN matched_if_stmt ELSE open_if_stmt
   49 stmt_list: . stmt stmt_list
   50          | . stmt
   51 expr_10: . expr_9 EQUALS expr_10
   52        | . expr_9 QUESTION expr_10 COLON expr_10
   53        | . expr_9
   54 expr_9: . expr_9 OR expr_8
   55       | . expr_8
   56 expr_8: . expr_8 AND expr_7
   57       | . expr_7
   58 expr_7: . expr_7 LT expr_6
   59       | . expr_7 LE expr_6
   60       | . expr_7 EE expr_6
   61       | . expr_7 GE expr_6
   62       | . expr_7 GT expr_6
   63       | . expr_7 NE expr_6
   64       | . expr_6
   65 expr_6: . expr_6 PLUS expr_5
   66       | . expr_6 MINUS expr_5
   67       | . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   90 expr_list: . expr_10 COMMA expr_list
   91          | . expr_10
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY
   97       | OPEN_CURLY . expr_list CLOSE_CURLY

    FOR              shift, and go to state 128
    IF               shift, and go to state 129
    PRINT            shift, and go to state 130
    RETURN           shift, and go to state 131
    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 132
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 133
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    decl_var         go to state 134
    stmt             go to state 135
    other_stmt       go to state 136
    if_stmt          go to state 137
    matched_if_stmt  go to state 138
    open_if_stmt     go to state 139
    stmt_list        go to state 150
    expr_10          go to state 151
    expr_9           go to state 37
    expr_8           go to state 38
    expr_7           go to state 39
    expr_6           go to state 40
    expr_5           go to state 41
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    expr_list        go to state 56
    atomic           go to state 48


State 134

   40 other_stmt: decl_var .

    $default  reduce using rule 40 (other_stmt)


State 135

    7 decl_var: . IDENTIFIER COLON type_var SEMICOLON
    8         | . IDENTIFIER COLON type_var EQUALS expr_10 SEMICOLON
   33 stmt: . if_stmt
   34 other_stmt: . RETURN expr_10 SEMICOLON
   35           | . RETURN SEMICOLON
   36           | . PRINT expr_list_e SEMICOLON
   37           | . OPEN_CURLY stmt_list CLOSE_CURLY
   38           | . expr_10 SEMICOLON
   39           | . FOR OPEN_PAREN expr_or_e SEMICOLON expr_or_e SEMICOLON expr_or_e CLOSE_PAREN stmt
   40           | . decl_var
   41 if_stmt: . matched_if_stmt
   42        | . open_if_stmt
   43 matched_if_stmt: . IF OPEN_PAREN expr_10 CLOSE_PAREN matched_if_stmt ELSE matched_if_stmt
   44                | . other_stmt
   45 open_if_stmt: . IF OPEN_PAREN expr_10 CLOSE_PAREN if_stmt
   46             | . IF OPEN_PAREN expr_10 CLOSE_PAREN matched_if_stmt ELSE open_if_stmt
   49 stmt_list: . stmt stmt_list
   49          | stmt . stmt_list
   50          | . stmt
   50          | stmt .  [CLOSE_CURLY]
   51 expr_10: . expr_9 EQUALS expr_10
   52        | . expr_9 QUESTION expr_10 COLON expr_10
   53        | . expr_9
   54 expr_9: . expr_9 OR expr_8
   55       | . expr_8
   56 expr_8: . expr_8 AND expr_7
   57       | . expr_7
   58 expr_7: . expr_7 LT expr_6
   59       | . expr_7 LE expr_6
   60       | . expr_7 EE expr_6
   61       | . expr_7 GE expr_6
   62       | . expr_7 GT expr_6
   63       | . expr_7 NE expr_6
   64       | . expr_6
   65 expr_6: . expr_6 PLUS expr_5
   66       | . expr_6 MINUS expr_5
   67       | . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    FOR              shift, and go to state 128
    IF               shift, and go to state 129
    PRINT            shift, and go to state 130
    RETURN           shift, and go to state 131
    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 132
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 133
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    $default  reduce using rule 50 (stmt_list)

    decl_var         go to state 134
    stmt             go to state 135
    other_stmt       go to state 136
    if_stmt          go to state 137
    matched_if_stmt  go to state 138
    open_if_stmt     go to state 139
    stmt_list        go to state 152
    expr_10          go to state 141
    expr_9           go to state 37
    expr_8           go to state 38
    expr_7           go to state 39
    expr_6           go to state 40
    expr_5           go to state 41
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 136

   44 matched_if_stmt: other_stmt .

    $default  reduce using rule 44 (matched_if_stmt)


State 137

   33 stmt: if_stmt .

    $default  reduce using rule 33 (stmt)


State 138

   41 if_stmt: matched_if_stmt .

    $default  reduce using rule 41 (if_stmt)


State 139

   42 if_stmt: open_if_stmt .

    $default  reduce using rule 42 (if_stmt)


State 140

    9 decl_func: IDENTIFIER COLON FUNCTION type_func OPEN_PAREN param_list_e CLOSE_PAREN EQUALS OPEN_CURLY stmt_list . CLOSE_CURLY

    CLOSE_CURLY  shift, and go to state 153


State 141

   38 other_stmt: expr_10 . SEMICOLON

    SEMICOLON  shift, and go to state 154


State 142

   26 type_param: ARRAY OPEN_SQUARE CLOSE_SQUARE type_param .

    $default  reduce using rule 26 (type_param)


State 143

   20 type_param: . INTEGER
   21           | . BOOLEAN
   22           | . CHAR
   23           | . STRING
   24           | . AUTO
   25           | . ARRAY OPEN_SQUARE expr_10 CLOSE_SQUARE type_param
   25           | ARRAY OPEN_SQUARE expr_10 CLOSE_SQUARE . type_param
   26           | . ARRAY OPEN_SQUARE CLOSE_SQUARE type_param

    ARRAY    shift, and go to state 111
    AUTO     shift, and go to state 112
    BOOLEAN  shift, and go to state 113
    CHAR     shift, and go to state 114
    INTEGER  shift, and go to state 115
    STRING   shift, and go to state 116

    type_param  go to state 155


State 144

   39 other_stmt: FOR OPEN_PAREN . expr_or_e SEMICOLON expr_or_e SEMICOLON expr_or_e CLOSE_PAREN stmt
   47 expr_or_e: . expr_10
   48          | . %empty  [SEMICOLON]
   51 expr_10: . expr_9 EQUALS expr_10
   52        | . expr_9 QUESTION expr_10 COLON expr_10
   53        | . expr_9
   54 expr_9: . expr_9 OR expr_8
   55       | . expr_8
   56 expr_8: . expr_8 AND expr_7
   57       | . expr_7
   58 expr_7: . expr_7 LT expr_6
   59       | . expr_7 LE expr_6
   60       | . expr_7 EE expr_6
   61       | . expr_7 GE expr_6
   62       | . expr_7 GT expr_6
   63       | . expr_7 NE expr_6
   64       | . expr_6
   65 expr_6: . expr_6 PLUS expr_5
   66       | . expr_6 MINUS expr_5
   67       | . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    $default  reduce using rule 48 (expr_or_e)

    expr_or_e        go to state 156
    expr_10          go to state 157
    expr_9           go to state 37
    expr_8           go to state 38
    expr_7           go to state 39
    expr_6           go to state 40
    expr_5           go to state 41
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 145

   43 matched_if_stmt: IF OPEN_PAREN . expr_10 CLOSE_PAREN matched_if_stmt ELSE matched_if_stmt
   45 open_if_stmt: IF OPEN_PAREN . expr_10 CLOSE_PAREN if_stmt
   46             | IF OPEN_PAREN . expr_10 CLOSE_PAREN matched_if_stmt ELSE open_if_stmt
   51 expr_10: . expr_9 EQUALS expr_10
   52        | . expr_9 QUESTION expr_10 COLON expr_10
   53        | . expr_9
   54 expr_9: . expr_9 OR expr_8
   55       | . expr_8
   56 expr_8: . expr_8 AND expr_7
   57       | . expr_7
   58 expr_7: . expr_7 LT expr_6
   59       | . expr_7 LE expr_6
   60       | . expr_7 EE expr_6
   61       | . expr_7 GE expr_6
   62       | . expr_7 GT expr_6
   63       | . expr_7 NE expr_6
   64       | . expr_6
   65 expr_6: . expr_6 PLUS expr_5
   66       | . expr_6 MINUS expr_5
   67       | . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    expr_10          go to state 158
    expr_9           go to state 37
    expr_8           go to state 38
    expr_7           go to state 39
    expr_6           go to state 40
    expr_5           go to state 41
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 146

   36 other_stmt: PRINT expr_list_e . SEMICOLON

    SEMICOLON  shift, and go to state 159


State 147

   35 other_stmt: RETURN SEMICOLON .

    $default  reduce using rule 35 (other_stmt)


State 148

   34 other_stmt: RETURN expr_10 . SEMICOLON

    SEMICOLON  shift, and go to state 160


State 149

    7 decl_var: IDENTIFIER COLON . type_var SEMICOLON
    8         | IDENTIFIER COLON . type_var EQUALS expr_10 SEMICOLON
   27 type_var: . INTEGER
   28         | . BOOLEAN
   29         | . CHAR
   30         | . STRING
   31         | . AUTO
   32         | . ARRAY OPEN_SQUARE expr_10 CLOSE_SQUARE type_var

    ARRAY    shift, and go to state 10
    AUTO     shift, and go to state 11
    BOOLEAN  shift, and go to state 12
    CHAR     shift, and go to state 13
    INTEGER  shift, and go to state 15
    STRING   shift, and go to state 16

    type_var  go to state 17


State 150

   37 other_stmt: OPEN_CURLY stmt_list . CLOSE_CURLY

    CLOSE_CURLY  shift, and go to state 161


State 151

   38 other_stmt: expr_10 . SEMICOLON
   90 expr_list: expr_10 . COMMA expr_list
   91          | expr_10 .  [CLOSE_CURLY]

    SEMICOLON  shift, and go to state 154
    COMMA      shift, and go to state 86

    $default  reduce using rule 91 (expr_list)


State 152

   49 stmt_list: stmt stmt_list .

    $default  reduce using rule 49 (stmt_list)


State 153

    9 decl_func: IDENTIFIER COLON FUNCTION type_func OPEN_PAREN param_list_e CLOSE_PAREN EQUALS OPEN_CURLY stmt_list CLOSE_CURLY .

    $default  reduce using rule 9 (decl_func)


State 154

   38 other_stmt: expr_10 SEMICOLON .

    $default  reduce using rule 38 (other_stmt)


State 155

   25 type_param: ARRAY OPEN_SQUARE expr_10 CLOSE_SQUARE type_param .

    $default  reduce using rule 25 (type_param)


State 156

   39 other_stmt: FOR OPEN_PAREN expr_or_e . SEMICOLON expr_or_e SEMICOLON expr_or_e CLOSE_PAREN stmt

    SEMICOLON  shift, and go to state 162


State 157

   47 expr_or_e: expr_10 .

    $default  reduce using rule 47 (expr_or_e)


State 158

   43 matched_if_stmt: IF OPEN_PAREN expr_10 . CLOSE_PAREN matched_if_stmt ELSE matched_if_stmt
   45 open_if_stmt: IF OPEN_PAREN expr_10 . CLOSE_PAREN if_stmt
   46             | IF OPEN_PAREN expr_10 . CLOSE_PAREN matched_if_stmt ELSE open_if_stmt

    CLOSE_PAREN  shift, and go to state 163


State 159

   36 other_stmt: PRINT expr_list_e SEMICOLON .

    $default  reduce using rule 36 (other_stmt)


State 160

   34 other_stmt: RETURN expr_10 SEMICOLON .

    $default  reduce using rule 34 (other_stmt)


State 161

   37 other_stmt: OPEN_CURLY stmt_list CLOSE_CURLY .

    $default  reduce using rule 37 (other_stmt)


State 162

   39 other_stmt: FOR OPEN_PAREN expr_or_e SEMICOLON . expr_or_e SEMICOLON expr_or_e CLOSE_PAREN stmt
   47 expr_or_e: . expr_10
   48          | . %empty  [SEMICOLON]
   51 expr_10: . expr_9 EQUALS expr_10
   52        | . expr_9 QUESTION expr_10 COLON expr_10
   53        | . expr_9
   54 expr_9: . expr_9 OR expr_8
   55       | . expr_8
   56 expr_8: . expr_8 AND expr_7
   57       | . expr_7
   58 expr_7: . expr_7 LT expr_6
   59       | . expr_7 LE expr_6
   60       | . expr_7 EE expr_6
   61       | . expr_7 GE expr_6
   62       | . expr_7 GT expr_6
   63       | . expr_7 NE expr_6
   64       | . expr_6
   65 expr_6: . expr_6 PLUS expr_5
   66       | . expr_6 MINUS expr_5
   67       | . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    $default  reduce using rule 48 (expr_or_e)

    expr_or_e        go to state 164
    expr_10          go to state 157
    expr_9           go to state 37
    expr_8           go to state 38
    expr_7           go to state 39
    expr_6           go to state 40
    expr_5           go to state 41
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 163

    7 decl_var: . IDENTIFIER COLON type_var SEMICOLON
    8         | . IDENTIFIER COLON type_var EQUALS expr_10 SEMICOLON
   34 other_stmt: . RETURN expr_10 SEMICOLON
   35           | . RETURN SEMICOLON
   36           | . PRINT expr_list_e SEMICOLON
   37           | . OPEN_CURLY stmt_list CLOSE_CURLY
   38           | . expr_10 SEMICOLON
   39           | . FOR OPEN_PAREN expr_or_e SEMICOLON expr_or_e SEMICOLON expr_or_e CLOSE_PAREN stmt
   40           | . decl_var
   41 if_stmt: . matched_if_stmt
   42        | . open_if_stmt
   43 matched_if_stmt: . IF OPEN_PAREN expr_10 CLOSE_PAREN matched_if_stmt ELSE matched_if_stmt
   43                | IF OPEN_PAREN expr_10 CLOSE_PAREN . matched_if_stmt ELSE matched_if_stmt
   44                | . other_stmt
   45 open_if_stmt: . IF OPEN_PAREN expr_10 CLOSE_PAREN if_stmt
   45             | IF OPEN_PAREN expr_10 CLOSE_PAREN . if_stmt
   46             | . IF OPEN_PAREN expr_10 CLOSE_PAREN matched_if_stmt ELSE open_if_stmt
   46             | IF OPEN_PAREN expr_10 CLOSE_PAREN . matched_if_stmt ELSE open_if_stmt
   51 expr_10: . expr_9 EQUALS expr_10
   52        | . expr_9 QUESTION expr_10 COLON expr_10
   53        | . expr_9
   54 expr_9: . expr_9 OR expr_8
   55       | . expr_8
   56 expr_8: . expr_8 AND expr_7
   57       | . expr_7
   58 expr_7: . expr_7 LT expr_6
   59       | . expr_7 LE expr_6
   60       | . expr_7 EE expr_6
   61       | . expr_7 GE expr_6
   62       | . expr_7 GT expr_6
   63       | . expr_7 NE expr_6
   64       | . expr_6
   65 expr_6: . expr_6 PLUS expr_5
   66       | . expr_6 MINUS expr_5
   67       | . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    FOR              shift, and go to state 128
    IF               shift, and go to state 129
    PRINT            shift, and go to state 130
    RETURN           shift, and go to state 131
    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 132
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 133
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    decl_var         go to state 134
    other_stmt       go to state 136
    if_stmt          go to state 165
    matched_if_stmt  go to state 166
    open_if_stmt     go to state 139
    expr_10          go to state 141
    expr_9           go to state 37
    expr_8           go to state 38
    expr_7           go to state 39
    expr_6           go to state 40
    expr_5           go to state 41
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 164

   39 other_stmt: FOR OPEN_PAREN expr_or_e SEMICOLON expr_or_e . SEMICOLON expr_or_e CLOSE_PAREN stmt

    SEMICOLON  shift, and go to state 167


State 165

   45 open_if_stmt: IF OPEN_PAREN expr_10 CLOSE_PAREN if_stmt .

    $default  reduce using rule 45 (open_if_stmt)


State 166

   41 if_stmt: matched_if_stmt .  [ELSE, FOR, IF, PRINT, RETURN, INTEGER_LITERAL, BOOLEAN_LITERAL, CHAR_LITERAL, STRING_LITERAL, IDENTIFIER, OPEN_PAREN, OPEN_CURLY, CLOSE_CURLY, MINUS, NOT]
   43 matched_if_stmt: IF OPEN_PAREN expr_10 CLOSE_PAREN matched_if_stmt . ELSE matched_if_stmt
   46 open_if_stmt: IF OPEN_PAREN expr_10 CLOSE_PAREN matched_if_stmt . ELSE open_if_stmt

    ELSE  shift, and go to state 168

    ELSE      [reduce using rule 41 (if_stmt)]
    $default  reduce using rule 41 (if_stmt)


State 167

   39 other_stmt: FOR OPEN_PAREN expr_or_e SEMICOLON expr_or_e SEMICOLON . expr_or_e CLOSE_PAREN stmt
   47 expr_or_e: . expr_10
   48          | . %empty  [CLOSE_PAREN]
   51 expr_10: . expr_9 EQUALS expr_10
   52        | . expr_9 QUESTION expr_10 COLON expr_10
   53        | . expr_9
   54 expr_9: . expr_9 OR expr_8
   55       | . expr_8
   56 expr_8: . expr_8 AND expr_7
   57       | . expr_7
   58 expr_7: . expr_7 LT expr_6
   59       | . expr_7 LE expr_6
   60       | . expr_7 EE expr_6
   61       | . expr_7 GE expr_6
   62       | . expr_7 GT expr_6
   63       | . expr_7 NE expr_6
   64       | . expr_6
   65 expr_6: . expr_6 PLUS expr_5
   66       | . expr_6 MINUS expr_5
   67       | . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 31
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 33
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    $default  reduce using rule 48 (expr_or_e)

    expr_or_e        go to state 169
    expr_10          go to state 157
    expr_9           go to state 37
    expr_8           go to state 38
    expr_7           go to state 39
    expr_6           go to state 40
    expr_5           go to state 41
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 168

    7 decl_var: . IDENTIFIER COLON type_var SEMICOLON
    8         | . IDENTIFIER COLON type_var EQUALS expr_10 SEMICOLON
   34 other_stmt: . RETURN expr_10 SEMICOLON
   35           | . RETURN SEMICOLON
   36           | . PRINT expr_list_e SEMICOLON
   37           | . OPEN_CURLY stmt_list CLOSE_CURLY
   38           | . expr_10 SEMICOLON
   39           | . FOR OPEN_PAREN expr_or_e SEMICOLON expr_or_e SEMICOLON expr_or_e CLOSE_PAREN stmt
   40           | . decl_var
   43 matched_if_stmt: . IF OPEN_PAREN expr_10 CLOSE_PAREN matched_if_stmt ELSE matched_if_stmt
   43                | IF OPEN_PAREN expr_10 CLOSE_PAREN matched_if_stmt ELSE . matched_if_stmt
   44                | . other_stmt
   45 open_if_stmt: . IF OPEN_PAREN expr_10 CLOSE_PAREN if_stmt
   46             | . IF OPEN_PAREN expr_10 CLOSE_PAREN matched_if_stmt ELSE open_if_stmt
   46             | IF OPEN_PAREN expr_10 CLOSE_PAREN matched_if_stmt ELSE . open_if_stmt
   51 expr_10: . expr_9 EQUALS expr_10
   52        | . expr_9 QUESTION expr_10 COLON expr_10
   53        | . expr_9
   54 expr_9: . expr_9 OR expr_8
   55       | . expr_8
   56 expr_8: . expr_8 AND expr_7
   57       | . expr_7
   58 expr_7: . expr_7 LT expr_6
   59       | . expr_7 LE expr_6
   60       | . expr_7 EE expr_6
   61       | . expr_7 GE expr_6
   62       | . expr_7 GT expr_6
   63       | . expr_7 NE expr_6
   64       | . expr_6
   65 expr_6: . expr_6 PLUS expr_5
   66       | . expr_6 MINUS expr_5
   67       | . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    FOR              shift, and go to state 128
    IF               shift, and go to state 129
    PRINT            shift, and go to state 130
    RETURN           shift, and go to state 131
    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 132
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 133
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    decl_var         go to state 134
    other_stmt       go to state 136
    matched_if_stmt  go to state 170
    open_if_stmt     go to state 171
    expr_10          go to state 141
    expr_9           go to state 37
    expr_8           go to state 38
    expr_7           go to state 39
    expr_6           go to state 40
    expr_5           go to state 41
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 169

   39 other_stmt: FOR OPEN_PAREN expr_or_e SEMICOLON expr_or_e SEMICOLON expr_or_e . CLOSE_PAREN stmt

    CLOSE_PAREN  shift, and go to state 172


State 170

   43 matched_if_stmt: IF OPEN_PAREN expr_10 CLOSE_PAREN matched_if_stmt ELSE matched_if_stmt .

    $default  reduce using rule 43 (matched_if_stmt)


State 171

   46 open_if_stmt: IF OPEN_PAREN expr_10 CLOSE_PAREN matched_if_stmt ELSE open_if_stmt .

    $default  reduce using rule 46 (open_if_stmt)


State 172

    7 decl_var: . IDENTIFIER COLON type_var SEMICOLON
    8         | . IDENTIFIER COLON type_var EQUALS expr_10 SEMICOLON
   33 stmt: . if_stmt
   34 other_stmt: . RETURN expr_10 SEMICOLON
   35           | . RETURN SEMICOLON
   36           | . PRINT expr_list_e SEMICOLON
   37           | . OPEN_CURLY stmt_list CLOSE_CURLY
   38           | . expr_10 SEMICOLON
   39           | . FOR OPEN_PAREN expr_or_e SEMICOLON expr_or_e SEMICOLON expr_or_e CLOSE_PAREN stmt
   39           | FOR OPEN_PAREN expr_or_e SEMICOLON expr_or_e SEMICOLON expr_or_e CLOSE_PAREN . stmt
   40           | . decl_var
   41 if_stmt: . matched_if_stmt
   42        | . open_if_stmt
   43 matched_if_stmt: . IF OPEN_PAREN expr_10 CLOSE_PAREN matched_if_stmt ELSE matched_if_stmt
   44                | . other_stmt
   45 open_if_stmt: . IF OPEN_PAREN expr_10 CLOSE_PAREN if_stmt
   46             | . IF OPEN_PAREN expr_10 CLOSE_PAREN matched_if_stmt ELSE open_if_stmt
   51 expr_10: . expr_9 EQUALS expr_10
   52        | . expr_9 QUESTION expr_10 COLON expr_10
   53        | . expr_9
   54 expr_9: . expr_9 OR expr_8
   55       | . expr_8
   56 expr_8: . expr_8 AND expr_7
   57       | . expr_7
   58 expr_7: . expr_7 LT expr_6
   59       | . expr_7 LE expr_6
   60       | . expr_7 EE expr_6
   61       | . expr_7 GE expr_6
   62       | . expr_7 GT expr_6
   63       | . expr_7 NE expr_6
   64       | . expr_6
   65 expr_6: . expr_6 PLUS expr_5
   66       | . expr_6 MINUS expr_5
   67       | . expr_5
   68 expr_5: . expr_5 MULTIPLY expr_4
   69       | . expr_5 DIVIDE expr_4
   70       | . expr_5 REMAINDER expr_4
   71       | . expr_4
   72 expr_4: . expr_3 EXP expr_4
   73       | . expr_3
   74 expr_3: . MINUS expr_3
   75       | . NOT expr_3
   76       | . expr_2
   77 expr_2: . expr_2 INCREMENT
   78       | . expr_2 DECREMENT
   79       | . expr_1
   80 expr_1: . OPEN_PAREN expr_10 CLOSE_PAREN
   81       | . func_call
   82       | . array_subscript
   83       | . atomic
   84 func_call: . IDENTIFIER OPEN_PAREN expr_list_e CLOSE_PAREN
   85 array_subscript: . IDENTIFIER bracket_set
   92 atomic: . INTEGER_LITERAL
   93       | . BOOLEAN_LITERAL
   94       | . CHAR_LITERAL
   95       | . STRING_LITERAL
   96       | . IDENTIFIER
   97       | . OPEN_CURLY expr_list CLOSE_CURLY

    FOR              shift, and go to state 128
    IF               shift, and go to state 129
    PRINT            shift, and go to state 130
    RETURN           shift, and go to state 131
    INTEGER_LITERAL  shift, and go to state 27
    BOOLEAN_LITERAL  shift, and go to state 28
    CHAR_LITERAL     shift, and go to state 29
    STRING_LITERAL   shift, and go to state 30
    IDENTIFIER       shift, and go to state 132
    OPEN_PAREN       shift, and go to state 32
    OPEN_CURLY       shift, and go to state 133
    MINUS            shift, and go to state 34
    NOT              shift, and go to state 35

    decl_var         go to state 134
    stmt             go to state 173
    other_stmt       go to state 136
    if_stmt          go to state 137
    matched_if_stmt  go to state 138
    open_if_stmt     go to state 139
    expr_10          go to state 141
    expr_9           go to state 37
    expr_8           go to state 38
    expr_7           go to state 39
    expr_6           go to state 40
    expr_5           go to state 41
    expr_4           go to state 42
    expr_3           go to state 43
    expr_2           go to state 44
    expr_1           go to state 45
    func_call        go to state 46
    array_subscript  go to state 47
    atomic           go to state 48


State 173

   39 other_stmt: FOR OPEN_PAREN expr_or_e SEMICOLON expr_or_e SEMICOLON expr_or_e CLOSE_PAREN stmt .

    $default  reduce using rule 39 (other_stmt)
